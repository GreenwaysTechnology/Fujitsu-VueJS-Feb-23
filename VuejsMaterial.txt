Pre Knowledge:

1.HTML 5
2.CSS 3
3.Javascript -ES 5 and ES 6
4.Node js fundamentals - npm
.....................................................................................
			  Vue js 3.x
.....................................................................................
What is Vue.js?
  Vue.js is a javascript framework for building user interfaces.

What is javascript?
   Javascript is programming language, was created to build web apps for browsers.
 Now a days javascript is every where, from browser to server and mobile.

javascript frameworks for building user interfaces

1.JQuery
2.Angular js
3.React js
4.Angular 2.x - 17
5.Vue js
etc....

javascript frameworks for building server side apps
1.express js
2.hapi js
3.Moleculer
4.Loopback
5.Next js
6.nest js
7.Nuxt js
etc.....

User interface could be browser,mobile apps,desktop,other device based apps.

Vue is more popular for building browser based web applications.
.....................................................................................

What are different types of Web Applications?


Web History
https://home.web.cern.ch/science/computing/birth-web

Server side web apps
1.static web apps - 1989 to 1995
   -HTML
2.Dynamic content generation web app -1996 to till date
   -CGI - C/Perl
   -J2EE - Java,JavaServlets
   -ASP  - Vbscript,VB
   -PHP  - Php
output : HTML
 etc.....
3.Web Services - ECOMMERCE(B2 to B2) - 1998 To till date
  DATA is exchanged between two systems 
  Common data formats
   -XML - SOAP web services
  -Multi format(JSON)- RESTFull Web Services / GraphQL 
..................................................................................


Client side web apps

Netscap communication introduced a web browser called "Navigator".

Navigator started failing down once microsoft announced free browser in 1995 as part of win 95 os.

Netscap started entering in to server side market,but again failed.

1995 netscap team started thinking about new technology- how to process "html pages" in the client side after rendering - Client side web apps.

Client Side Web Architecture:

Browser-HTML
.....................................................................................
			How browser renders HTML
		    Internals of HTML Representation
....................................................................................

HTML is programming language -  DSL pl /declarative pl.


index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
-------------------Browser
loader---LOAD Code into browser
 |
   from file: or http:
 |
Parser : Parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
.....................................................................................

.....................................................................................
				Runtime  -  Allocate Memory for HTML
...........................................................................................				
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList - c
body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body

-Nodes are connected each other in hierachical structure(tree)
 
Linking the Nodes: Tree (c)

body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
body
 |
 |
Layout/Paint Engine: will convert nodes into pxs : final output
...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec - DOM
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be represented as Objects" : Object oriented Document Programming.

According to DOM?

Any html element is represented as "Node" inside browser engine, "Object" as inside javascript engine.

div = DIV object
.............................................................................................
				Birth of Frameworks and libs

...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?




............................................................................................
How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                Every Html ELEMENT Inside Browser is "C Program"

	        Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.

.............................................................................................
				DOM Programming
.............................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js
.....................................................................................
			Client side web apps and vue js
....................................................................................
Vue is client side web app framework.
but
Now a days vue can be used to build server side web apps as well

Client side web apps:
   Apps is executed at client side(browser)

->SPA - Single page web app (This is what we are going to learn)

You can use vue.js framwork
->Enchancing html(genereated by server) by adding javascript /js lib(jquery)
->Web component model

Server side web apps:
   App is executed at server side and result (html) page is sent to browser.

Full stack/SSR (Server side Rendering)
JAM Stack/SSG (Static Site Generation)

You can use vue+NUXT
Based on ,use case we can pickup any one of the methods to build client side web apps, but most popular one is SPA,SSR

Vue js can be used to build any type of client side web apps(spa,ssr,ssg)
....................................................................................
	     Vuejs Application Developement Getting started
.....................................................................................

Implementation

1.Standalone Script

Vue can be used as a standalone script file - no build step required! If you have a backend framework already rendering most of the HTML(Java,php,aspx), or your frontend logic isn't complex enough to justify a build step, this is the easiest way to integrate Vue into your stack. You can think of Vue as a more declarative replacement of jQuery in such cases

Use case :
 What if your project is very old project, written in java/.net/php which uses jquer or plain js for html modification, Modern requirement is that we dont want to change the back end framework but i want to use modern js stack-You can use vue js.

=>It is old model of writing code.
=>server always creates html pages , sends html to browser
=>Client side we need to submit forms
   we need to validate the forms-js can be used.
   some animations 
   if you want to submit forms to the server for processing some data
   (ajax)

Technologies:
  jQuery
  Vue.js

2.Single-Page Application (SPA):

  Some applications require rich interactivity and non-trivial stateful logic on the frontend. The best way to build such applications is to use an architecture where Vue not only controls the entire page, but also handles data updates and navigation without having to reload the page. This type of application is typically referred to as a Single-Page Application (SPA).

SPAs typically require the backend to expose API endpoints - but you can also pair Vue with solutions like Inertia.js to get the SPA benefits while retaining a server-centric development model.

....................................................................................



Project Setup:
..............

1.without build tools

2.with build tools

 Build tool
   It is tool by using this tool we can create,manage,run the projects


1.Standalone Script:
   Applications are written without using build only.

2.SPA 
    Applications are written with using build only



>mkdir vue-legacy

vue-legacy>mkdir src

Steps:

1.create Project

>mkdir vue-legacy

vue-legacy>mkdir src

vue-legacy>code .

create index.html outside src dir

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
</head>
<body>
    
</body>
</html>

After adding html we need to run html, we need web server.

Vs code has plugin called "live server" which is built in web server- You have to install "live server" plugin(Extensions)

After running, we need to add "vue js" framwork.

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build


Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
    <!-- This is dev build -->
    <script src="https://unpkg.com/vue@3"></script>
    <!-- This is production build -->
    <!-- <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script> -->
</head>
<body>
   
</body>

</html>
.....................................................................................
DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.


Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

   <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('create Element')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement();
    </script>

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates

Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			   java script => binds the state(data)

...................................................................................
How Vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue Organizes the UI into Smaller and Smaller UI
=>Vue Breaks complex UI into Smaller UI
   This model is called Composition

Why Composition?
=>The UI can be reused any where in the app.
=>The code maintaince is very easy,because it is independant.

           This arch is called as "component driven arch"

.....................................................................................

Steps:

1.create Application Object

Pro Vue 3.
var app = new Vue({   })


Vue 3:

1.1.Get Vue Instance

We can get Vue Instance 

A.Via Global Vue variable
B.Via ES 6 modules

....................................................................................
			A.Via Global Vue variable
...................................................................................

How to get Vue instance?
 First we have to get Vue instance then only we can create application.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vueApp</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Vue is global variable provied by vue framework
        let vue = Vue
        console.log(vue)
    </script>
</body>

</html>

Vue instance is having so many methods(apis)
............................................

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 

What is Application Object?

  Application object is object which is container object which encapsulate vue app.


How to create Application Object?

 in order to create application object, we need to get vue instance first.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vueApp</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Vue is global variable provied by vue framework
        let vue = Vue
        console.log(vue)
        //Vue Application object
        const app = vue.createApp()
        console.log(app)
    </script>
</body>

</html>
...................................................................................
				Short cuts 

1.To get vue instance and createApp 

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vueApp</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Get vue instance and create App
        //way 1:
        const app = Vue.createApp()
        console.log(app)

        //way 2: ES 6 Destructuring 
        const { createApp } = Vue
        const myapp = createApp()
        console.log(myapp)
    </script>
</body>

</html>

.....................................................................................
			B.Via ES 6 Modules
.....................................................................................

ES 6 module:

if you come java, you are familer with "Packages"
if you come .net , you are familer with "namespaces"
JS organsizes the code as modules 
  Common js Module
  ES 6 Module

ES 6 module most populare and standard.

Any module who provides how to share code and how to link code.


in order to link code, we use "import" keyword
in order to share code, we use "export ,export default" keyword.


Note:
 these keywords cant be understood by browser directly, but modern browsers support,
 There are build tools such as webpack, who converts module code into browser understandable format,


Demo:

src/message.js

export function sayHello() {
    return 'Hello'
}
src/index.js
import { sayHello } from "./message"

function main() {
    console.log(sayHello())
}
main()

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="src/index.js"></script>
</head>

<body>

</body>

</html>

After running , you get the following error message

Uncaught SyntaxError: Cannot use import statement outside a module (at index.js:1:1)

Because browsers dont support "ES 6 module keywords-export,import,export default" directly.

Then how to run this?

There are two solutions

1.Use build tool to convert this code into browser understandable format.

2.Use modern browser technique


How to use browser itself?

<script src="src/index.js" type="module"></script>


After this also you may get error?

GET http://127.0.0.1:5500/src/message net::ERR_ABORTED 404 (Not Found)

 here message is not found.

Solution:
 when you import , you have to add "./message.js"


src/index.js
import { sayHello } from "./message.js"

function main() {
    console.log(sayHello())
}
main()
....................................................................................
			import js file into html directly
....................................................................................


if you want import any js code within html file.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>    
    <script type="importmap">
        {
          "imports": {
          
          }
        }
      </script> 
</head>
<body>    
    <!-- <script src="src/index.js" type="module"></script> -->

</body>
</html>

eg:

src/name.js
export const name = 'Subramanian'

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "name":"./src/name.js"
         }
       }
    </script>
</head>

<body>
    <script type="module">
        import { name } from 'name'
        console.log(name)
    </script>

</body>

</html>

Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

  <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>


With Polyfil:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "name":"./src/name.js"
         }
       }
    </script>
</head>

<body>
    <script type="module">
        import { name } from 'name'
        console.log(name)
    </script>

</body>

</html>
.....................................................................................
			Integrate Vue js using es 6 module syntax
....................................................................................

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "name":"./src/name.js",
             "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
         }
       }
    </script>
</head>

<body>
    <script type="module">
        import { name } from 'name'
        import { createApp } from 'vue'
        console.log(name)
        const app = createApp()
        console.log(app)
    </script>

</body>

</html>

Vue is Root Instance having lot methods (factory methods)

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 
etc...
.....................................................................................
			  User interface Development
.....................................................................................

User interface development guidelines:

1.User interface must be broken into smallar and smallar -  Compostion - Component model

2.User interface is organized in hierachal structure -  Tree Structure 
  Thats where html has been designed.
 We need to follow html tree model

 <div>
    <div>
	<div>
	   
	</div>
	
    </div>
 </div>

3.In tree model there must be one root element

..................................................................................
				Root Component(root Element)


In React:
 function Logo(){
   
   return <img src="logo.png"/>
 
}
In Angular

 @Component({
   selector:'app-logo'
   template:`<img src="logo.png"/>
 }) 
 export class Logo{

 }
In Vue:
 Component is object which is represented as literal object.

const Logo ={

}
....................................................................................

First UI:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
         }
       }
    </script>
</head>

<body>
    <div id="root">

    </div>

    <script type="module">
        import { createApp } from 'vue'
        //create application object
        const app = createApp({
            template: `<div>
                    <h1>Welcome to Vue js Applicaiton</h1>    
            </div>`
        })
        console.log(app)
        //will mount/insert the template into existing html tree
        app.mount('#root')

    </script>

</body>

</html>
.....................................................................................
		   How to isloate component into separate file 

src/components/RootComponent.js


export default {
    template: '<h1>Welcome</h1>'
}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
             "root" : "./src/components/RootComponent.js"
         }
       }
    </script>
</head>

<body>
    <div id="root">

    </div>

    <script type="module">
        import { createApp } from 'vue'
        import rootComponent from 'root'
        //component definition

        //create application object
        const app = createApp(rootComponent)
        console.log(app)
        //will mount/insert the template into existing html tree
        app.mount('#root')

    </script>

</body>

</html>
.....................................................................................
				Component Composition
....................................................................................

As we discussed, HTML is based on tree pattern, similar way we have design UI - we have to break ui into components, and finally we have to compose.

src/components/WelcomeCompoent.js

export default {
    template: '<h1>Welcome</h1>'
}

src/components/RootComponent.js
import WelcomeComponent from "./WelcomeComponent.js"

export default {
    components: { WelcomeComponent },
    template: '<WelcomeComponent></WelcomeComponent>'
}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
             "root" : "./src/components/RootComponent.js"
         }
       }
    </script>
</head>

<body>
    <div id="root">
	
    </div>

    <script type="module">
        import { createApp } from 'vue'
        import rootComponent from 'root'
        //component definition

        //create application object
        const app = createApp(rootComponent)
        console.log(app)
        //will mount/insert the template into existing html tree
        app.mount('#root')

    </script>

</body>

</html>

.....................................................................................
				Component Properties
................................................................................

What a Component Contains?

const Welcome = {
 template:'',
 components:{},
 render:'',
 compilerOptions:{},
 data:function(){}
}
etc..

component information can be categorized into various segments

1.UI/Rendering - HTML,CSS(Markup)
..................................
 template
 render
 compilerOptions

2.State -(data) - javascript
 data 
 props
 computed
 methods
 watch
 emits
 expose

3.Life Cycle hooks(methods)
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

4.Composition
 provide
 inject
 mixins
 extends

Misc
name
inheritAttrs
components
directives

Component Instance api
$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()
.....................................................................................
			Vue Application setup using build tools
.....................................................................................

Build tools are js based tools for create,manage js apps work flows.
Build tools based on npm tool.

Setup Vue Project using build tool based: CLI based apporach.
.............................................................

There are two cli tools

1.Vue-cli
  https://cli.vuejs.org/#getting-started
Vue- cli is now in maintance mode, meaning that , which is only used for creating old vue project(v2)

2.Vite
https://vitejs.dev/guide/
Next Generation Frontend Tooling project, used to create no of project types.


We are going to follow Vite base project setup

npm init vue@latest

This is abstraction for vite based project templates

npm init vue@latest
Need to install the following packages:
create-vue@3.9.2
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in E:\session\Fujitsu\vue-app...

Done. Now run:

  cd vue-app
  npm install
  npm run dev
....................................................................................
			Folders and files
.....................................................................................

package.json
  ->any js project must contain this file.

{
  "name": "vue-app",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.4.15"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.3",
    "vite": "^5.0.11"
  }
}

vite.config.js
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

index.html
 It is entry file which initalized when app starts.
 When index.html is initalized, the inital dom tree is intialzed and also vue app  initalized


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

Here , script tag which includes main.js which is entry point for vue application.

src/main.js
import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')

Here "createApp" function is imported from "vue Instance"..

"App" is root Component.

We insert/mount into "index.html" under <div id="app"></div> 

src/App.vue
src/components
src/assets

public
  folder contains all assets like images /fonts/documents

node_modules:
  contains all project dependencies
...................................................................................

How to start the app?

  npm run dev


internal process:

 1.vite compiler starts compiling ".vue" files into javascript.
 2.vite bundler(rollup) packs code for execution in browser..
 3.App is hosted in the webserver which is embeded by vite..
 4.App is running in 5173 port 

.....................................................................................
			 Vue coding style
.....................................................................................

Vue coding can be classified into category..

1.Vue 2.x style
2.Vue 3.x Style

Note:
 We may compare both styles when we write code....

Vue application can be classified based on "API" Style:
.......................................................

1.Options API Based Style
      Vue 2.x and also Vue 3.x
2.Composition API based Style
    Vue 3.x 

....................................................................................
			Compoent Creational patterns
....................................................................................


Component can be saved

fileName.js 
  This is  used only when we dont use build tools.
  This is only suitable for "Standalone" Script pattern...

App.js
 export default {

 }

fileName.vue
   This is used only when we use build tool (vite based)
   This is only suitable for "SPA" Web Apps
 
....................................................................................
			imperative and declarative programming style


1.Plain Java script Pattern

App.js
export default {
  
  ...options 
  
}

It is more imperative style of creating components

2.Single File Component-SFC Pattern

App.vue

 It is more declarative way of creating component
 As name suggests,All components logic inside single file.

Components have three major segment:

1.template 
   collection of html elements and vue instructions
2.javascript
   collection of variables,methods
3.style 
   css style for a component

In SFC Pattern, we isloate very clearly into three sections

<script>
   ....All javascript code
</script>
<template>
  ...template code
</template>
<style>
 //style for this component
</style>
      
   
Plain javascript pattern is usefull where there is no build workflow,SFC is usefull and necessary in build tool work flow 

		  SFC components are saved with fileName.vue
		Plain javascript pattern files are saved with fileName.js


eg: Plain JS pattern
src/components/App.js
//Component creation based on js extension: without build tool 
export default {
    template: `
             <h1>Vue Application!</h1>
            `,
    //rest of the apis

}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Polyfil lib for importmap -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
              "vue":"https://unpkg.com/vue@3/dist/vue.esm-browser.js",
              "app": "./src/components/App.js"
          }
        }
      </script>
</head>

<body>

    <div id="root">
        <!-- Insert dom node -->
    </div>
    <script type="module">
        //step 1: import factory method
        import { createApp } from 'vue'
        import  Application  from 'app'
        //step 2: create app instance
        // const app = createApp({
        //     template: `<h1> Welcome to Vue Application</h1>`
        // })
        const app = createApp(Application)
        //Step 3: Mount the component into root element
        app.mount("#root")

    </script>
</body>

</html>
....................................................................................
			Single File Component Pattern -SFC

App.vue
<!-- I am going to write SFC -->
<!-- Three sections : script,template,style -->
<script>
// Here all js logic goes
</script>
<template>
    <!-- Here all html ui logic goes -->
    <h1>Welcome to Vue JS app</h1>
</template>
<style>
/* Here styling logic goes */
</style>

	      Going forward we focus only "SFC" Pattern
....................................................................................
		Classification of SFC Pattern based on script
...................................................................................

Inside script section we write javascript logic, this javascript can be written using two styles.

1.Options Api style 
    vue 2.x style...
2.Composition Api style
   vue 3.x style.

Inside optionsApi we can write both vue 2.x code and 3.x

....................................................................................
			Commonality between both patterns
 			(Options api and Composition api)

1.code segementation is same
  <script></script>
  <template></template>
  <style></style>


Options Api Pattern:
......................
In options Api Pattern, we return Options Object , which contains neccessary configurations.

options object must be exported using "export default".

<!-- Options api -->
<script>
export default {
    //options or Configuration
    props: ['something'],
    data: function () {
        return 'Subramanian'
    }
}
</script>
<template>
    <h1>Welcome to Vue JS app</h1>
</template>
<style></style>

....................................................................................
			  Composition Api Pattern

In this pattern we define a component logic's using imported Api functions
In this pattern we write code directly inside script.
Composition Api pattern was introduced in vue 3.x 
Composition api pattern is Simplified pattern of "Options Api pattern"
Composition api pattern is built on the top of options api.


Composition api pattern again is classifed into two patterns.


With Setup function:


<!-- Composition Api Pattern with setup function -->
<script>
export default {
    setup() {
        //all js logic will go
    }
}
</script>
<template>
    <h1>Welcome to Vue JS app</h1>
</template>
<style></style>

With setup attribute.
<!-- Composition Api Pattern with setup attribute -->
<script setup>
// javascript logic 
</script>
<template>
    <h1>Welcome to Vue JS app</h1>
</template>
<style></style>


 				Vue App
				   |
			---------------------------------------  
			With Build tool                  without build tool
				 |				|
			SFC Component            	 Script based (refer above)
				   |
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api
	 |                                                          |
   Vue 2 based apps                                           Vue 3 based apps
							        												|	
		  							|
				----------------------------------------------------
				|                                       |
	      	with setup function                           with setup attribute	

....................................................................................
			    Component Composition
.....................................................................................

As we discussed , the html is tree pattern

 <div> -Parent
    <div> -Child,Parent
	<div> -Child
	    <p></p>      ---|
            <span></span>---| sibilings
	</div>
    <div>
 <div>

Component Structure

 Parent
   |
  Child
     |
     Child
.....................................................................................
 				 Component Composition
	                     SFC Pattern Using Options API
......................................................................................

src/components/Hello.vue

<script>
export default {

}
</script>
<template>
    <div>
        <h1>Hello</h1>
    </div>
</template>

src/components/Welcome.vue

<script>
import Hello from './Hello.vue';

export default {
    components: { Hello }
}
</script>
<template>
    <div>
        <!-- <Hello></Hello> -->
        <Hello/>
    </div>
</template>

src/App.vue
<!-- Component Composition using Options api -->
<script>
import Welcome from './components/Welcome.vue';
export default {
    //components
    components: {
        //Welcome: Welcome
        Welcome //ES6 object destructuring syntax
    }
}
</script>
<template>
    <h1>Component Composition using Options Api</h1>
    <Welcome></Welcome>
</template>

.....................................................................................
 				 Component Composition
	                     SFC Pattern Using Composition API
				   setup function
.....................................................................................
src/components/App.vue
<!-- Component composition using Compostion api -setup function -->

<script>
import Greeter from './components/Greeter.vue';

export default {
    components: { Greeter },
    setup() {
    },
}
</script>
<template>
    <Greeter />
</template>

src/components/Greeter.vue
<script>
export default {
    setup() {

    }
}
</script>
<template>
    <h1>Greeter</h1>
</template>
.....................................................................................
 				 Component Composition
	                     SFC Pattern Using Composition API
				   setup attribute
.....................................................................................
src/App.vue
<script setup>
import Message from './components/Message.vue'
</script>
<template>
    <Message />
</template>
src/components/Message.vue
<script setup>

</script>
<template>
    <h1>Message</h1>
</template>
....................................................................................
Assigment:

You have to build layout.

Page
  |
   Header
	|
	Logo
        SearchPanel
        LoginPanel
  |
  Main
    -Three sections
	-Vue features
  |
  Footer
     |
     CopyRight
     Address

This layout you have to build using options and composition(setup fun and attribute).
  ...................................................................................
............................&&&&&&&&&&..............................................
		 Component Registeration -Creations
.....................................................................................

A Vue component needs to be "registered" so that Vue knows where to locate its implmeneation when it is encountered in a template.


Two Types of Registeration:

1.Global Registeration
  Global Components
2.Local Registeration
  Local Components

Global Registration and Global Components:
..........................................

if a component is registered globally, that component is called "Global Components".


=>Global components are registered with "application object".

Application object having lot of methods

app.component()
app.use()
app.directive()
app.provide()
etc...

// register an options object
app.component('my-component', {
  /* ... */
})

// retrieve a registered component
const MyComponent = app.component('my-component')


src/components/StatusBar.vue
<script setup>
</script>
<template>
    <h1>StatusBar</h1>
</template>

src/main.js
// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/StatusBar.vue'
//createApp(App).mount('#app')
const app = createApp(App)

console.log(app)

//Global components
app.component('StatusBar', StatusBar)

//mount
app.mount('#app')

How to use Global  Components?

The same syntax, but what ever pattern you use Options api or compositions api with setup fun or attribute.

You can refer global components any where in the application.

You dont need even import also, you can refer directly.

<script setup>
import Message from './components/Message.vue'
// import StatusBar from './components/StatusBar.vue'
</script>
<template>
    <Message />
    <StatusBar></StatusBar>
</template>
....................................................................................

			 Local Components Registration
................................................................................

Components are registered when the child component is created

SFC using composition pattern using setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>

SFC using composition pattern using without setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'

export default {
   components: { 
         ComponentsA
   }
}
</script>

<template>
  <ComponentA />
</template>

..................................................................................
			Both local and global compoents
...................................................................................
<script>
import Hello from './components/greeter/Hello.vue';
export default {
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <StatusBar></StatusBar>
    <Hello></Hello>
</template>
<style>
</style>
...................................................................................
			Global Vs Local Component Registration
.................................................................................

=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").
=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.

=>This can affect long-term maintainability similar to using too many global variables.

=>Global Components need to be imported inside any where

<script>
// import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <StatusBar></StatusBar>
    <Hello></Hello>
</template>
<style>
</style>
....................................................................................
....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).



This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   <greeter>
Vue supports both cases , but highly recommened is Pascal Case

eg:
<script>
//import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    //Hello is just Component
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <!-- Pascal Case -->
    <!-- <StatusBar></StatusBar> -->
    <!-- <Hello></Hello> -->
    <!-- dash-case/ kebab-case -->
    <status-bar></status-bar>
    <hello></hello>
</template>
<style>
</style>
....................................................................................
			 Vue dev Tool
....................................................................................
This is developer tool installed as part of browser plugin used for understanding component structure and its relationship.

https://devtools.vuejs.org/

.....................................................................................
			    Templates
...................................................................................
Template is the representation of View
View is Runtime representation
				
Template can be static or dynamic 

Static templates are having pure html code
Dynamic templates are having html code + Vue instructions
Vue instructions are special symbols

Template  = html + vue instructions(data,events,props...)


Data Binding:
    Passing data from the component to "View-UI"  and View to Component

Types of Data bidning:

1.interpolation
2.property /props binding
3.attribute binding
4.event binding
5.Two way data binding
6.class and style binding
.....................................................................................
.....................................................................................
			  MVC  Architecture
....................................................................................

In order to build user interface we have architectures

1.MVC 
  It is the most legacy arch but still more popular arch, used in server side,client   side app developments

2.Flex 
   It is discovered by face book, in order to replace MVC , primarily used in React..

Vue js is MVC Based  and Flex mixed arch -hybrid arch..

M - Model - State - Data
V - View  - User interface
C - Controller - Having data and biz logic

Vue and MVC:

<script>
  M + C -> logic
</script>
<template>
   View Logic - Ui
</template>
<style>

</style>

component = {Model + Controller(Script,View(template,style)}
....................................................................................
				Interpolation
...................................................................................

Transfering state(data) from controller to View.

State:
  State can be represented in two ways...

1.Primitives
   numbers,string,booleans
 let name='Subramaian'

2.Objects and Collections -  literal objects and arrays

  let profile = {
    id:1,
    name:'xxx'
  }

SFC:
 1.Using Options api
 2.Using Compostion api
    -with setup fun
    -with setup attribute

1.Using options api

let options = {
  components: {},
  data: function(){},  
}

State Declarations and Options api:
...................................

src/compoents/Greeter.vue
<script>
export default {
    //data/state declaration
    data() {
        //must return object -state
        return {
            name: 'Subramanian'
        }
    }

}
</script>
<template>
    <h1>Welcome to </h1>
</template>

src/App.vue
<script>
import Greeter from './components/Greeter.vue'
export default {
  components: { Greeter }
}
</script>
<template>
  <Greeter />
</template>

We  have declared data inside data function.

How to show or bind the data inside template?

Vue offers the syntax called binding - interpolation - {{variable}}

src/compoents/Greeter.vue
<script>
export default {
    //data/state declaration
    data() {
        //must return object -state
        return {
            name: 'Subramanian'
        }
    }

}
</script>
<template>
    <h1>Welcome to {{ name }} </h1>
</template>
.....................................................................................
			Binding all types of data
.....................................................................................


src/compoents/Profile.vue
<script>
export default {
    data() {
        return {
            id: 1,
            firstName: 'Subramanain',
            lastName: 'Murugan',
            points: 100,
            status: true,
            address: {
                city: 'Coimbatore',
                state: 'Tamil Nadu',
                country: 'India',
            }
        }
    }
}
</script>
<template>
    <h1>ID {{ id }}</h1>
    <h2>Name {{ firstName }} {{ lastName }}</h2>
    <h3>Points {{ points }}</h3>
    <h3>Status {{ status ? 'Available' : 'Not Available' }}</h3>
    <address>
        <p>{{ address.city }}, {{ address.state }}</p>
    </address>
</template>
<style></style>

src/App.vue
<script>
import Profile from './components/Profile.vue';
export default {
    components: { Profile }
}
</script>
<template>
    <Profile />
</template>
.....................................................................................
			Using Compostion api -setup function
.....................................................................................

The component logic must be encapsulated inside a function called "setup"
The setup function must return state

export default {
  setup(){
     //variables 
     //state	
     return {}
  }

}

src/compoents/Profile.vue
<script>
export default {
    setup() {
        const id = 1;
        const firstName = 'Subramanian'
        const lastName = 'Murugan';
        const status = true
        const address = {
            city: "Coimbatore",
            state: "Tamil Nadu"
        }
        return {
            id,
            firstName,
            lastName,
            status,
            address
        }
    }
}
</script>
<template>
    <h1>ID {{ id }}</h1>
    <h2>Name {{ firstName }} {{ lastName }}</h2>
    <h3>Points {{ points }}</h3>
    <h3>Status {{ status ? 'Available' : 'Not Available' }}</h3>
    <address>
        <p>{{ address.city }}, {{ address.state }}</p>
    </address>
</template>
<style></style>

src/App.vue

<script>
import Profile from './components/Profile.vue';
export default {
    components: { Profile },
    setup() {

    }
}
</script>
<template>
    <Profile />
</template> 

...................................................................................
			Compostion api using set up attribute
.....................................................................................

src/components/Profile.vue
<script setup>
const id = 1;
const firstName = 'Subramanian'
const lastName = 'Murugan';
const status = true
const address = {
    city: "Coimbatore",
    state: "Tamil Nadu"
}
</script>
<template>
    <h1>ID {{ id }}</h1>
    <h2>Name {{ firstName }} {{ lastName }}</h2>
    <h3>Points {{ points }}</h3>
    <h3>Status {{ status ? 'Available' : 'Not Available' }}</h3>
    <address>
        <p>{{ address.city }}, {{ address.state }}</p>
    </address>
</template>
<style></style>
....................................................................................
				Directives
..................................................................................

What is directive?
  Directive is object which helps to create custom elements and attributes.
  Directives enchances existing html elements - We extend the functionality of HTML   elements.

HTML elements Types:

1.Built in element and attributes
2.Custom elements and attributes

Built in Elements:
  The elements which are provided by html language.
<div>
<h1>

HTML Compiler Work flow:
.......................


<h1>Hello</h1> -----Compiler verfies this element is built in or not
				|
		   --------------------------------
		   |                              |
                 Yes                             No
		  |                              |
Browser parses, the                    Brower throws exception                                                               called "UnknownElement"
element and convert                    which is converted into plain ascii node
it , render accordingly


<app-drawer> - it is custom element, generally browser does not under stand.

In 2007, W3c introduced new idea that developers can add their own tags/elements(custom elements and custom attributes).
   HTML 5 Specification


built in element logic is already written, so that browser easily understands that.

What about custom element, how to teach browser to understand custom elements?
    
  "Through Javascript"

<app-drawer> ---|JS Code--->Runs ---renders in the browser....
   
Every Component  element is custom element.

src/components/AppDrawer.vue
<script setup>
</script>
<template>
    <h1>App Drawer</h1>
</template>

src/App.vue
<script setup>
import AppDrawer from './components/AppDrawer.vue';
</script>
<template>
    <!-- Custom element  -->
    <app-drawer></app-drawer>
</template>

Directive is also custom element, component is subclass of Directive.
.....................................................................................
			  HTML ATTRIBUTES 
.....................................................................................
Types of HTML Attributes

1.InBuilt Attributes
2.Custom Attributes

InBuilt Attributes:

<img src="" alt="">
      |      |
       Attributes - Built in Attributes

Browser knows how to put logic to src and alt.

2.Custom Attributes

 <img abc />
       |
    custom attribute

How to teach browser to parse custom attributes?
    "Through javascript"

How to create custom attributes?
  Via Directives

You can see already vue is adding custom attributes 

<div id="app" data-v-app>

</div>

Here data-v-app is custom attribute(directive)
................................................................................

Vue js helps to add custom attributes on existing elements via "directives" - Attribute Directives

Vue js attribute directive syntax:

v-directiveName

Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

Special Attributes
key
ref
is
....................................................................................
			 V-text and v-html
.....................................................................................

v-html and v-text is alternate to {{}} for data binding

<!-- Data binding with directives -->

<script setup>
const firstName = 'Subramanian'
</script>
<template>
    <h1>Interpolation using mustache notation</h1>
    <p>Name {{ firstName }}</p>
    <h1>Interpolation using Directives v-text</h1>
    <p v-text="`Name ${firstName}`"></p>
    <h1>Interpolation using Directives v-html</h1>
    <p v-html="`Name ${firstName}`"></p>
</template>

{{}} and v-text -output would be "Plain Text" -rawText
v-html -output would be "innerHTML" -rawhtml

....................................................................................
			 v-bind
...................................................................................

v-binds binds html attributes values or components values(properties) dynamically.

Binding: Attach value to the attribute

Types of binding

1.Static binding
 
   Binding attribute values once,it cant be changed during runtime.

eg:
   <img src="logo.png"/>
         |      |
  attribute   attribute value
  The value of "src" cant be changed once ui is rendered

2.Dynamic binding
 Binding attribute values initalialy, later can be changed during runtime.
 dynamic binding can be implemented using "v-bind" directive

  <img v-bind:src="variableHoldingImage"/>
  shortcut:
  <img :src="variableHoldingImage"/>


<script setup>
const logoUrl = "/src/assets/logo.svg"
const isEnabled = true
const isHidden = false
</script>
<template>
    <div>
        <h1>Bind Directives</h1>
        <div>
            <h2>Static Binding</h2>
            <img src="./assets/logo.svg" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Binding with v-bind</h2>
            <img v-bind:src="logoUrl" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Binding with v-bind shortcut</h2>
            <img :src="logoUrl" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Binding with Button Enabled and Disabled state</h2>
            <button :disabled="isEnabled">Hello</button>
        </div>
        <div>
            <h2>Dynamic Binding with Article Show and Hidden</h2>
            <article :hidden="isHidden">
                <p>This is article</p>
            </article>
        </div>
    </div>
</template>
.....................................................................................
			  Props - Property Binding
.....................................................................................

Component Driven Design principles:

Role of Components / Responsibility of Component:
..................................................

Component having state,bizlogic,ui

As per component design design principles , we need to apply modularity concept.
  Break the component based on two aspects

1.Having data and biz logic
    -Parent Component /Container component
2.Having UI logic
    -Child Component/Presentational Component

Data(State) Sharing Patterns/ Data(State) Representation Patterns:
....................................................

1.Props Pattern
  The data is shared from the Parent Component to Child Component.
2.State Pattern
   The data is represented within in component and change it.

Syntax:
 From Parent Component Template

  <Child title="Hello" />
          |        |  
Property Name   Property Value

How to structure a Large scale vue.js app

Default strcture

src
  |
  components
    |
    User 
    Product
    Comments
    Payment
 |
 App.vue
 main.js

Standard Structure of apps would be domain model

src
  |
  components
    |
    User 
      Userlist.vue
      UserDetails.vue
      User.vue
   Product	
      ProductList.vue
      ProductDetails.vue
      Product.vue
   stores
   layouts
   plugins
   directives
   helpers/utils
...................................................................................
			  Props/Property -Pattern Implementation
...................................................................................

How to pass data from the parent component to child component?

We have many api styles (options and composition api(setup fun/setup attribute)

Props with Options Api.
.......................

Static Binding: 
  Props value once supplied cant be passed value dynamically.

src/components/products/ProductMaster.vue
<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: { ProductDetails }
}
</script>
<template>
    <h1>Product Master</h1>
    <!-- sending data from Productmaster to ProductDetails -->
    <ProductDetails title="Product Details Page"></ProductDetails>
</template>


src/components/products/ProductDetails.vue
<script>
export default {
    props: ['title']
}
</script>
<template>
    <h1>{{ title }}</h1>
</template>

src/App.vue
<script setup>
import ProductMaster from './components/products/ProductMaster.vue'

</script>
<template>
  <h1>App</h1>
  <ProductMaster></ProductMaster>
</template>
.....................................................................................

How to pass object as prop? Dynamic values?
  Using v-bind:prop or :prop 

src/components/products/ProductMaster.vue

<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: { ProductDetails },
    data() {
        return {
            product: {
                id: 1,
                name: 'IPHONE',
                model: '15 Max Pro',
                qty: 10,
                price: 124000,
                inStock: true
            }
        }
    }
}
</script>
<template>
    <h1>Product Master</h1>
    <!-- sending data from Productmaster to ProductDetails -->
    <!-- <ProductDetails title="Product Details Page" v-bind:product="product"></ProductDetails> -->
    <ProductDetails title="Product Details Page" :product="product"></ProductDetails>
</template>


src/components/products/ProductDetails.vue
<script>
export default {
    props: ['title', 'product']
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>Id {{ product.id }}</h1>
        <h2>Name {{ product.name }}</h2>
        <h2>Model {{ product.model }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? 'Available' : 'Out of Stock' }}</h2>

    </div>
</template>
...................................................................................
			 Props Composition Api - Setup function
....................................................................................

src/components/products/ProductMaster.vue
<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: { ProductDetails },
    setup() {
        return {
            product: {
                id: 1,
                name: 'IPHONE',
                model: '15 Max Pro',
                qty: 10,
                price: 124000,
                inStock: true
            }
        }
    }
}
</script>
<template>
    <h1>Product Master</h1>
    <ProductDetails title="Product Details Page" :product="product"></ProductDetails>
</template>


src/components/products/ProductDetails.vue
<script>
export default {
    props: ['title', 'product'],
    setup() {

    }
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>Id {{ product.id }}</h1>
        <h2>Name {{ product.name }}</h2>
        <h2>Model {{ product.model }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? 'Available' : 'Out of Stock' }}</h2>

    </div>
</template>
...................................................................................
			 Props Composition Api - Setup function
....................................................................................

src/components/products/ProductMaster.vue
<script setup>
import ProductDetails from './ProductDetails.vue'
const product = {
    id: 1,
    name: 'IPHONE',
    model: '15 Max Pro',
    qty: 10,
    price: 124000,
    inStock: true
}
</script>
<template>
    <h1>Product Master</h1>
    <ProductDetails title="Product Details Page" :product="product"></ProductDetails>
</template>

Reading props in setup attribute:
.................................
In vue 3 , we have function called "defineProps" which is global function, can be used to read props.

src/components/products/ProductDetails.vue
<script setup>
const props = defineProps(['title', 'product'])
</script>
<template>
    <h1>{{ props.title }}</h1>
    <div>
        <h1>Id {{ props.product.id }}</h1>
        <h2>Name {{ props.product.name }}</h2>
        <h2>Model {{ props.product.model }}</h2>
        <h2>Price {{ props.product.price }}</h2>
        <h2>Qty {{ props.product.qty }}</h2>
        <h2>Stock {{ props.product.inStock ? 'Available' : 'Out of Stock' }}</h2>

    </div>
</template>
..................................................................................
		What if , if you want to access props inside setup function

setup function takes "props" as arg through which you can access all properties supplied by parent component.

<script>
export default {
    props: ['title', 'product'],
    setup(props) {
        //how to access props inside setup function
        //console.log(this.props.title)
        console.log(props.title)

    }
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>Id {{ product.id }}</h1>
        <h2>Name {{ product.name }}</h2>
        <h2>Model {{ product.model }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? 'Available' : 'Out of Stock' }}</h2>

    </div>
</template>
....................................................................................
			 Property Validation
....................................................................................

Some times i want to enforce the property data type validation, which is only for runtime vertification.

eg:
 i have property called age
 i need to define rule for age that age must be number,it should not be string.

defineProps Syntax:

1.simple Syntax
defineProps(['propName','propName'])

2.Complex Syntax : prop validation rule, default value 
  
defineProps({
     age:Number,  
     id: [Number,String] // can be string or can be number
     name: {
      type:String
      required:true,
      default:'name'
     },
    status: {
	validator(value){
	  return ['OK','NotOk','Success','Failure'].includes(value)
       }
    }
 })
Runtime Types:
1.String
2.Number
3.Boolean
4.Array
5.Object
6.Date
7.Function
8.Symbol

src/components/User.vue
<script setup>
const props = defineProps({
    name: {
        type: String,
        default: 'Name is Missing'
    },
    id: {
        type: [Number, String],
        default: 0
    },
    status: {
        type: Boolean,
        default: false
    }
})
</script>
<template>
    <h1>Property validation</h1>
    <div>
        <h1>{{ props.id }}</h1>
        <h3>{{ props.name }}</h3>
        <h4>{{ props.status ? 'Available' : 'Not Available' }}</h4>
    </div>
</template>

src/App.vue
<script setup>
import User from './components/User.vue';
// const id = false
const id = 1
const name = 'Subramanian'
const status = true
</script>
<template>
    <h1>Property validation</h1>
    <User />
    <User :id="id" :name="name" :status="status" />
</template>
....................................................................................
		Can we modify the props value in Child Component
...................................................................................

As per component driven design rule, props cant be or should not be modifed by child component- Props are read only.


<script setup>
const props = defineProps({
    name: {
        type: String,
        default: 'Name is Missing'
    },
    id: {
        type: [Number, String],
        default: 0
    },
    status: {
        type: Boolean,
        default: false
    }
})
props.name = 'foo'
</script>
<template>
    <h1>Property validation</h1>
    <div>
        <h1>{{ props.id }}</h1>
        <h3>{{ props.name }}</h3>
        <h4>{{ props.status ? 'Available' : 'Not Available' }}</h4>
    </div>
</template>

Output:
Vue warn] Set operation on key "name" failed: target is readonly. Proxy(Object)
warn @ vue.js?v=2eb3f6c7:288
Show 1 more frame
Show less
vue.js?v=2eb3f6c7:288 [Vue warn] Set operation on key "name" failed: target is readonly. Proxy(Object)
....................................................................................

Assigment:

 You have to Create Customer Details

    -CustomerMaster
    -CustomerDetails

 I have to display different type of customers , you can change customer values dynamically... You can use hard-coded values

<CustomerDetails id="1"/>
<CustomerDetails id="2"/>
<CustomerDetails id="3"/>

	....................................................................................
			   Event Handling
....................................................................................
Event handling is one of the most popular concept in javascript as part of DOM programming.
Event handling helps to interact with user.
Events  are signals triggered by user or system, send to os system, the software or hardware reacts according to the event.

Events are classified into two category

1.Hardware events
   Triggered by user or system, interacts with hardware devices   
eg:
  Mouse events
    onclick,ondblclick,onmouseenter...
  https://www.w3schools.com/jsref/obj_mouseevent.asp
  Keyboard events
   onkeypress,onkeydown
  https://www.w3schools.com/jsref/event_onkeypress.asp
  Touch events
  ontouchstart,ontouchend
  https://www.w3schools.com/jsref/obj_touchevent.asp

2.Application events
   attached with objects called dom objects
   onload,oncomplete

...................................................................................
				        How event handling works

Event handling has been designed based on the design pattern called "pub-sub"/observer design pattern.

There are two actors:
1.Producer
   The producer is something who sends signals(events - name of the event and data assoicated) to the listener
2.Listener
  The Listener is someone who waits/listens for event.
  Once the event is given who reacts/respond

In js :
 Listener is function.

//event is just reference to the Event Object having information about event, and data
function listener(event){
     event.target.value
}
event object is a bridge between producer and listener

In javascript , events are given by language itself.

events are started with "on+eventName" - 
 onclick="listener"

addEventListener('click',listener)
  listeners are plain js functions with event object reference arg

Frameworks like vue,react,angular who adds their own abstractions.

We can attach event on any dom element which could be application or hardware

Vue Js and event handling:
..........................

Vue attaches events with any element with help of directive
                          "v-on"

Syntax:
1. v-on:NameOftheEvent="listener" -  v-on:click="update"
2. @click="listener" - @click="update"

Event Handling In Options API:
...............................
src/App.vue
<script>
export default {

  methods: {
    //listeners
    onIncrement(evt) {
      console.log('button is clicked')
    }
  }
}
</script>
<template>
  <h1>Event Handling</h1>
  <button v-on:click="onIncrement">Increment</button>
  <button @click="onIncrement">Increment</button>
</template>

Event Handling In Composition-Setup Function:
<script>
export default {
    setup() {
        //listener
        // function onIncrement(evt) {
        //     console.log('increment')
        // }
        //es 6 arrow functions
        const onIncrement = () => {
            console.log('increment')
        }
        //function must be returned
        return {
            onIncrement
        }
    }
}
</script>
<template>
    <h1>Event Handling</h1>
    <button @click="onIncrement">Increment</button>
</template>


Event Handling In Composition-Setup Attribute:

<script setup>
const onIncrement = () => {
    console.log('increment')
}
</script>
<template>
    <h1>Event Handling</h1>
    <button @click="onIncrement">Increment</button>
</template>



