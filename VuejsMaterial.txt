Pre Knowledge:

1.HTML 5
2.CSS 3
3.Javascript -ES 5 and ES 6
4.Node js fundamentals - npm
.....................................................................................
			  Vue js 3.x
.....................................................................................
What is Vue.js?
  Vue.js is a javascript framework for building user interfaces.

What is javascript?
   Javascript is programming language, was created to build web apps for browsers.
 Now a days javascript is every where, from browser to server and mobile.

javascript frameworks for building user interfaces

1.JQuery
2.Angular js
3.React js
4.Angular 2.x - 17
5.Vue js
etc....

javascript frameworks for building server side apps
1.express js
2.hapi js
3.Moleculer
4.Loopback
5.Next js
6.nest js
7.Nuxt js
etc.....

User interface could be browser,mobile apps,desktop,other device based apps.

Vue is more popular for building browser based web applications.
.....................................................................................

What are different types of Web Applications?


Web History
https://home.web.cern.ch/science/computing/birth-web

Server side web apps
1.static web apps - 1989 to 1995
   -HTML
2.Dynamic content generation web app -1996 to till date
   -CGI - C/Perl
   -J2EE - Java,JavaServlets
   -ASP  - Vbscript,VB
   -PHP  - Php
output : HTML
 etc.....
3.Web Services - ECOMMERCE(B2 to B2) - 1998 To till date
  DATA is exchanged between two systems 
  Common data formats
   -XML - SOAP web services
  -Multi format(JSON)- RESTFull Web Services / GraphQL 
..................................................................................


Client side web apps

Netscap communication introduced a web browser called "Navigator".

Navigator started failing down once microsoft announced free browser in 1995 as part of win 95 os.

Netscap started entering in to server side market,but again failed.

1995 netscap team started thinking about new technology- how to process "html pages" in the client side after rendering - Client side web apps.

Client Side Web Architecture:

Browser-HTML
.....................................................................................
			How browser renders HTML
		    Internals of HTML Representation
....................................................................................

HTML is programming language -  DSL pl /declarative pl.


index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
-------------------Browser
loader---LOAD Code into browser
 |
   from file: or http:
 |
Parser : Parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
.....................................................................................

.....................................................................................
				Runtime  -  Allocate Memory for HTML
...........................................................................................				
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList - c
body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body

-Nodes are connected each other in hierachical structure(tree)
 
Linking the Nodes: Tree (c)

body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
body
 |
 |
Layout/Paint Engine: will convert nodes into pxs : final output
...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec - DOM
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be represented as Objects" : Object oriented Document Programming.

According to DOM?

Any html element is represented as "Node" inside browser engine, "Object" as inside javascript engine.

div = DIV object
.............................................................................................
				Birth of Frameworks and libs

...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?




............................................................................................
How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                Every Html ELEMENT Inside Browser is "C Program"

	        Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.

.............................................................................................
				DOM Programming
.............................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js
.....................................................................................
			Client side web apps and vue js
....................................................................................
Vue is client side web app framework.
but
Now a days vue can be used to build server side web apps as well

Client side web apps:
   Apps is executed at client side(browser)

->SPA - Single page web app (This is what we are going to learn)

You can use vue.js framwork
->Enchancing html(genereated by server) by adding javascript /js lib(jquery)
->Web component model

Server side web apps:
   App is executed at server side and result (html) page is sent to browser.

Full stack/SSR (Server side Rendering)
JAM Stack/SSG (Static Site Generation)

You can use vue+NUXT
Based on ,use case we can pickup any one of the methods to build client side web apps, but most popular one is SPA,SSR

Vue js can be used to build any type of client side web apps(spa,ssr,ssg)
....................................................................................
	     Vuejs Application Developement Getting started
.....................................................................................

Implementation

1.Standalone Script

Vue can be used as a standalone script file - no build step required! If you have a backend framework already rendering most of the HTML(Java,php,aspx), or your frontend logic isn't complex enough to justify a build step, this is the easiest way to integrate Vue into your stack. You can think of Vue as a more declarative replacement of jQuery in such cases

Use case :
 What if your project is very old project, written in java/.net/php which uses jquer or plain js for html modification, Modern requirement is that we dont want to change the back end framework but i want to use modern js stack-You can use vue js.

=>It is old model of writing code.
=>server always creates html pages , sends html to browser
=>Client side we need to submit forms
   we need to validate the forms-js can be used.
   some animations 
   if you want to submit forms to the server for processing some data
   (ajax)

Technologies:
  jQuery
  Vue.js

2.Single-Page Application (SPA):

  Some applications require rich interactivity and non-trivial stateful logic on the frontend. The best way to build such applications is to use an architecture where Vue not only controls the entire page, but also handles data updates and navigation without having to reload the page. This type of application is typically referred to as a Single-Page Application (SPA).

SPAs typically require the backend to expose API endpoints - but you can also pair Vue with solutions like Inertia.js to get the SPA benefits while retaining a server-centric development model.

....................................................................................



Project Setup:
..............

1.without build tools

2.with build tools

 Build tool
   It is tool by using this tool we can create,manage,run the projects


1.Standalone Script:
   Applications are written without using build only.

2.SPA 
    Applications are written with using build only



>mkdir vue-legacy

vue-legacy>mkdir src

Steps:

1.create Project

>mkdir vue-legacy

vue-legacy>mkdir src

vue-legacy>code .

create index.html outside src dir

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
</head>
<body>
    
</body>
</html>

After adding html we need to run html, we need web server.

Vs code has plugin called "live server" which is built in web server- You have to install "live server" plugin(Extensions)

After running, we need to add "vue js" framwork.

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build


Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
    <!-- This is dev build -->
    <script src="https://unpkg.com/vue@3"></script>
    <!-- This is production build -->
    <!-- <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script> -->
</head>
<body>
   
</body>

</html>
.....................................................................................
DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.


Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

   <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('create Element')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement();
    </script>

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates

Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			   java script => binds the state(data)

...................................................................................
How Vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue Organizes the UI into Smaller and Smaller UI
=>Vue Breaks complex UI into Smaller UI
   This model is called Composition

Why Composition?
=>The UI can be reused any where in the app.
=>The code maintaince is very easy,because it is independant.

           This arch is called as "component driven arch"

.....................................................................................

Steps:

1.create Application Object

Pro Vue 3.
var app = new Vue({   })


Vue 3:

1.1.Get Vue Instance

We can get Vue Instance 

A.Via Global Vue variable
B.Via ES 6 modules

....................................................................................
			A.Via Global Vue variable
...................................................................................

How to get Vue instance?
 First we have to get Vue instance then only we can create application.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vueApp</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Vue is global variable provied by vue framework
        let vue = Vue
        console.log(vue)
    </script>
</body>

</html>

Vue instance is having so many methods(apis)
............................................

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 

What is Application Object?

  Application object is object which is container object which encapsulate vue app.


How to create Application Object?

 in order to create application object, we need to get vue instance first.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vueApp</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Vue is global variable provied by vue framework
        let vue = Vue
        console.log(vue)
        //Vue Application object
        const app = vue.createApp()
        console.log(app)
    </script>
</body>

</html>
...................................................................................
				Short cuts 

1.To get vue instance and createApp 

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vueApp</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Get vue instance and create App
        //way 1:
        const app = Vue.createApp()
        console.log(app)

        //way 2: ES 6 Destructuring 
        const { createApp } = Vue
        const myapp = createApp()
        console.log(myapp)
    </script>
</body>

</html>

.....................................................................................
			B.Via ES 6 Modules
.....................................................................................

ES 6 module:

if you come java, you are familer with "Packages"
if you come .net , you are familer with "namespaces"
JS organsizes the code as modules 
  Common js Module
  ES 6 Module

ES 6 module most populare and standard.

Any module who provides how to share code and how to link code.


in order to link code, we use "import" keyword
in order to share code, we use "export ,export default" keyword.


Note:
 these keywords cant be understood by browser directly, but modern browsers support,
 There are build tools such as webpack, who converts module code into browser understandable format,


Demo:

src/message.js

export function sayHello() {
    return 'Hello'
}
src/index.js
import { sayHello } from "./message"

function main() {
    console.log(sayHello())
}
main()

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="src/index.js"></script>
</head>

<body>

</body>

</html>

After running , you get the following error message

Uncaught SyntaxError: Cannot use import statement outside a module (at index.js:1:1)

Because browsers dont support "ES 6 module keywords-export,import,export default" directly.

Then how to run this?

There are two solutions

1.Use build tool to convert this code into browser understandable format.

2.Use modern browser technique


How to use browser itself?

<script src="src/index.js" type="module"></script>


After this also you may get error?

GET http://127.0.0.1:5500/src/message net::ERR_ABORTED 404 (Not Found)

 here message is not found.

Solution:
 when you import , you have to add "./message.js"


src/index.js
import { sayHello } from "./message.js"

function main() {
    console.log(sayHello())
}
main()
....................................................................................
			import js file into html directly
....................................................................................


if you want import any js code within html file.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>    
    <script type="importmap">
        {
          "imports": {
          
          }
        }
      </script> 
</head>
<body>    
    <!-- <script src="src/index.js" type="module"></script> -->

</body>
</html>

eg:

src/name.js
export const name = 'Subramanian'

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "name":"./src/name.js"
         }
       }
    </script>
</head>

<body>
    <script type="module">
        import { name } from 'name'
        console.log(name)
    </script>

</body>

</html>

Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

  <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>


With Polyfil:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "name":"./src/name.js"
         }
       }
    </script>
</head>

<body>
    <script type="module">
        import { name } from 'name'
        console.log(name)
    </script>

</body>

</html>
.....................................................................................
			Integrate Vue js using es 6 module syntax
....................................................................................

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "name":"./src/name.js",
             "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
         }
       }
    </script>
</head>

<body>
    <script type="module">
        import { name } from 'name'
        import { createApp } from 'vue'
        console.log(name)
        const app = createApp()
        console.log(app)
    </script>

</body>

</html>

Vue is Root Instance having lot methods (factory methods)

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 
etc...
.....................................................................................
			  User interface Development
.....................................................................................

User interface development guidelines:

1.User interface must be broken into smallar and smallar -  Compostion - Component model

2.User interface is organized in hierachal structure -  Tree Structure 
  Thats where html has been designed.
 We need to follow html tree model

 <div>
    <div>
	<div>
	   
	</div>
	
    </div>
 </div>

3.In tree model there must be one root element

..................................................................................
				Root Component(root Element)


In React:
 function Logo(){
   
   return <img src="logo.png"/>
 
}
In Angular

 @Component({
   selector:'app-logo'
   template:`<img src="logo.png"/>
 }) 
 export class Logo{

 }
In Vue:
 Component is object which is represented as literal object.

const Logo ={

}
....................................................................................

First UI:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
         }
       }
    </script>
</head>

<body>
    <div id="root">

    </div>

    <script type="module">
        import { createApp } from 'vue'
        //create application object
        const app = createApp({
            template: `<div>
                    <h1>Welcome to Vue js Applicaiton</h1>    
            </div>`
        })
        console.log(app)
        //will mount/insert the template into existing html tree
        app.mount('#root')

    </script>

</body>

</html>
.....................................................................................
		   How to isloate component into separate file 

src/components/RootComponent.js


export default {
    template: '<h1>Welcome</h1>'
}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
             "root" : "./src/components/RootComponent.js"
         }
       }
    </script>
</head>

<body>
    <div id="root">

    </div>

    <script type="module">
        import { createApp } from 'vue'
        import rootComponent from 'root'
        //component definition

        //create application object
        const app = createApp(rootComponent)
        console.log(app)
        //will mount/insert the template into existing html tree
        app.mount('#root')

    </script>

</body>

</html>
.....................................................................................
				Component Composition
....................................................................................

As we discussed, HTML is based on tree pattern, similar way we have design UI - we have to break ui into components, and finally we have to compose.

src/components/WelcomeCompoent.js

export default {
    template: '<h1>Welcome</h1>'
}

src/components/RootComponent.js
import WelcomeComponent from "./WelcomeComponent.js"

export default {
    components: { WelcomeComponent },
    template: '<WelcomeComponent></WelcomeComponent>'
}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <!-- <script src="src/index.js" type="module"></script> -->
    <script type="importmap">
       {
         "imports":{
             "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
             "root" : "./src/components/RootComponent.js"
         }
       }
    </script>
</head>

<body>
    <div id="root">
	
    </div>

    <script type="module">
        import { createApp } from 'vue'
        import rootComponent from 'root'
        //component definition

        //create application object
        const app = createApp(rootComponent)
        console.log(app)
        //will mount/insert the template into existing html tree
        app.mount('#root')

    </script>

</body>

</html>

.....................................................................................
				Component Properties
................................................................................

What a Component Contains?

const Welcome = {
 template:'',
 components:{},
 render:'',
 compilerOptions:{},
 data:function(){}
}
etc..

component information can be categorized into various segments

1.UI/Rendering - HTML,CSS(Markup)
..................................
 template
 render
 compilerOptions

2.State -(data) - javascript
 data 
 props
 computed
 methods
 watch
 emits
 expose

3.Life Cycle hooks(methods)
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

4.Composition
 provide
 inject
 mixins
 extends

Misc
name
inheritAttrs
components
directives

Component Instance api
$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()
.....................................................................................
			Vue Application setup using build tools
.....................................................................................

Build tools are js based tools for create,manage js apps work flows.
Build tools based on npm tool.

Setup Vue Project using build tool based: CLI based apporach.
.............................................................

There are two cli tools

1.Vue-cli
  https://cli.vuejs.org/#getting-started
Vue- cli is now in maintance mode, meaning that , which is only used for creating old vue project(v2)

2.Vite
https://vitejs.dev/guide/
Next Generation Frontend Tooling project, used to create no of project types.


We are going to follow Vite base project setup

npm init vue@latest

This is abstraction for vite based project templates

npm init vue@latest
Need to install the following packages:
create-vue@3.9.2
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in E:\session\Fujitsu\vue-app...

Done. Now run:

  cd vue-app
  npm install
  npm run dev
....................................................................................
			Folders and files
.....................................................................................

package.json
  ->any js project must contain this file.

{
  "name": "vue-app",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.4.15"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.3",
    "vite": "^5.0.11"
  }
}

vite.config.js
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

index.html
 It is entry file which initalized when app starts.
 When index.html is initalized, the inital dom tree is intialzed and also vue app  initalized


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

Here , script tag which includes main.js which is entry point for vue application.

src/main.js
import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')

Here "createApp" function is imported from "vue Instance"..

"App" is root Component.

We insert/mount into "index.html" under <div id="app"></div> 

src/App.vue
src/components
src/assets

public
  folder contains all assets like images /fonts/documents

node_modules:
  contains all project dependencies
...................................................................................

How to start the app?

  npm run dev


internal process:

 1.vite compiler starts compiling ".vue" files into javascript.
 2.vite bundler(rollup) packs code for execution in browser..
 3.App is hosted in the webserver which is embeded by vite..
 4.App is running in 5173 port 

.....................................................................................
			 Vue coding style
.....................................................................................

Vue coding can be classified into category..

1.Vue 2.x style
2.Vue 3.x Style

Note:
 We may compare both styles when we write code....

Vue application can be classified based on "API" Style:
.......................................................

1.Options API Based Style
      Vue 2.x and also Vue 3.x
2.Composition API based Style
    Vue 3.x 

....................................................................................
			Compoent Creational patterns
....................................................................................


Component can be saved

fileName.js 
  This is  used only when we dont use build tools.
  This is only suitable for "Standalone" Script pattern...

App.js
 export default {

 }

fileName.vue
   This is used only when we use build tool (vite based)
   This is only suitable for "SPA" Web Apps
 
....................................................................................
			imperative and declarative programming style


1.Plain Java script Pattern

App.js
export default {
  
  ...options 
  
}

It is more imperative style of creating components

2.Single File Component-SFC Pattern

App.vue

 It is more declarative way of creating component
 As name suggests,All components logic inside single file.

Components have three major segment:

1.template 
   collection of html elements and vue instructions
2.javascript
   collection of variables,methods
3.style 
   css style for a component

In SFC Pattern, we isloate very clearly into three sections

<script>
   ....All javascript code
</script>
<template>
  ...template code
</template>
<style>
 //style for this component
</style>
      
   
Plain javascript pattern is usefull where there is no build workflow,SFC is usefull and necessary in build tool work flow 

		  SFC components are saved with fileName.vue
		Plain javascript pattern files are saved with fileName.js


eg: Plain JS pattern
src/components/App.js
//Component creation based on js extension: without build tool 
export default {
    template: `
             <h1>Vue Application!</h1>
            `,
    //rest of the apis

}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Polyfil lib for importmap -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
              "vue":"https://unpkg.com/vue@3/dist/vue.esm-browser.js",
              "app": "./src/components/App.js"
          }
        }
      </script>
</head>

<body>

    <div id="root">
        <!-- Insert dom node -->
    </div>
    <script type="module">
        //step 1: import factory method
        import { createApp } from 'vue'
        import  Application  from 'app'
        //step 2: create app instance
        // const app = createApp({
        //     template: `<h1> Welcome to Vue Application</h1>`
        // })
        const app = createApp(Application)
        //Step 3: Mount the component into root element
        app.mount("#root")

    </script>
</body>

</html>
....................................................................................
			Single File Component Pattern -SFC

App.vue
<!-- I am going to write SFC -->
<!-- Three sections : script,template,style -->
<script>
// Here all js logic goes
</script>
<template>
    <!-- Here all html ui logic goes -->
    <h1>Welcome to Vue JS app</h1>
</template>
<style>
/* Here styling logic goes */
</style>

	      Going forward we focus only "SFC" Pattern
....................................................................................
		Classification of SFC Pattern based on script
...................................................................................

Inside script section we write javascript logic, this javascript can be written using two styles.

1.Options Api style 
    vue 2.x style...
2.Composition Api style
   vue 3.x style.

Inside optionsApi we can write both vue 2.x code and 3.x

....................................................................................
			Commonality between both patterns
 			(Options api and Composition api)

1.code segementation is same
  <script></script>
  <template></template>
  <style></style>


Options Api Pattern:
......................
In options Api Pattern, we return Options Object , which contains neccessary configurations.

options object must be exported using "export default".

<!-- Options api -->
<script>
export default {
    //options or Configuration
    props: ['something'],
    data: function () {
        return 'Subramanian'
    }
}
</script>
<template>
    <h1>Welcome to Vue JS app</h1>
</template>
<style></style>

....................................................................................
			  Composition Api Pattern

In this pattern we define a component logic's using imported Api functions
In this pattern we write code directly inside script.
Composition Api pattern was introduced in vue 3.x 
Composition api pattern is Simplified pattern of "Options Api pattern"
Composition api pattern is built on the top of options api.


Composition api pattern again is classifed into two patterns.


With Setup function:


<!-- Composition Api Pattern with setup function -->
<script>
export default {
    setup() {
        //all js logic will go
    }
}
</script>
<template>
    <h1>Welcome to Vue JS app</h1>
</template>
<style></style>

With setup attribute.
<!-- Composition Api Pattern with setup attribute -->
<script setup>
// javascript logic 
</script>
<template>
    <h1>Welcome to Vue JS app</h1>
</template>
<style></style>


 				Vue App
				   |
			---------------------------------------  
			With Build tool                  without build tool
				 |				|
			SFC Component            	 Script based (refer above)
				   |
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api
	 |                                                          |
   Vue 2 based apps                                           Vue 3 based apps
							        												|	
		  							|
				----------------------------------------------------
				|                                       |
	      	with setup function                           with setup attribute	

....................................................................................
			    Component Composition
.....................................................................................

As we discussed , the html is tree pattern

 <div> -Parent
    <div> -Child,Parent
	<div> -Child
	    <p></p>      ---|
            <span></span>---| sibilings
	</div>
    <div>
 <div>

Component Structure

 Parent
   |
  Child
     |
     Child
.....................................................................................
 				 Component Composition
	                     SFC Pattern Using Options API
......................................................................................

src/components/Hello.vue

<script>
export default {

}
</script>
<template>
    <div>
        <h1>Hello</h1>
    </div>
</template>

src/components/Welcome.vue

<script>
import Hello from './Hello.vue';

export default {
    components: { Hello }
}
</script>
<template>
    <div>
        <!-- <Hello></Hello> -->
        <Hello/>
    </div>
</template>

src/App.vue
<!-- Component Composition using Options api -->
<script>
import Welcome from './components/Welcome.vue';
export default {
    //components
    components: {
        //Welcome: Welcome
        Welcome //ES6 object destructuring syntax
    }
}
</script>
<template>
    <h1>Component Composition using Options Api</h1>
    <Welcome></Welcome>
</template>

.....................................................................................
 				 Component Composition
	                     SFC Pattern Using Composition API
				   setup function
.....................................................................................
src/components/App.vue
<!-- Component composition using Compostion api -setup function -->

<script>
import Greeter from './components/Greeter.vue';

export default {
    components: { Greeter },
    setup() {
    },
}
</script>
<template>
    <Greeter />
</template>

src/components/Greeter.vue
<script>
export default {
    setup() {

    }
}
</script>
<template>
    <h1>Greeter</h1>
</template>
.....................................................................................
 				 Component Composition
	                     SFC Pattern Using Composition API
				   setup attribute
.....................................................................................
src/App.vue
<script setup>
import Message from './components/Message.vue'
</script>
<template>
    <Message />
</template>
src/components/Message.vue
<script setup>

</script>
<template>
    <h1>Message</h1>
</template>
....................................................................................
Assigment:

You have to build layout.

Page
  |
   Header
	|
	Logo
        SearchPanel
        LoginPanel
  |
  Main
    -Three sections
	-Vue features
  |
  Footer
     |
     CopyRight
     Address

This layout you have to build using options and composition(setup fun and attribute).
  ...................................................................................
............................&&&&&&&&&&..............................................
		 Component Registeration -Creations
.....................................................................................

A Vue component needs to be "registered" so that Vue knows where to locate its implmeneation when it is encountered in a template.


Two Types of Registeration:

1.Global Registeration
  Global Components
2.Local Registeration
  Local Components

Global Registration and Global Components:
..........................................

if a component is registered globally, that component is called "Global Components".


=>Global components are registered with "application object".

Application object having lot of methods

app.component()
app.use()
app.directive()
app.provide()
etc...

// register an options object
app.component('my-component', {
  /* ... */
})

// retrieve a registered component
const MyComponent = app.component('my-component')


src/components/StatusBar.vue
<script setup>
</script>
<template>
    <h1>StatusBar</h1>
</template>

src/main.js
// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/StatusBar.vue'
//createApp(App).mount('#app')
const app = createApp(App)

console.log(app)

//Global components
app.component('StatusBar', StatusBar)

//mount
app.mount('#app')

How to use Global  Components?

The same syntax, but what ever pattern you use Options api or compositions api with setup fun or attribute.

You can refer global components any where in the application.

You dont need even import also, you can refer directly.

<script setup>
import Message from './components/Message.vue'
// import StatusBar from './components/StatusBar.vue'
</script>
<template>
    <Message />
    <StatusBar></StatusBar>
</template>
....................................................................................

			 Local Components Registration
................................................................................

Components are registered when the child component is created

SFC using composition pattern using setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>

SFC using composition pattern using without setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'

export default {
   components: { 
         ComponentsA
   }
}
</script>

<template>
  <ComponentA />
</template>

..................................................................................
			Both local and global compoents
...................................................................................
<script>
import Hello from './components/greeter/Hello.vue';
export default {
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <StatusBar></StatusBar>
    <Hello></Hello>
</template>
<style>
</style>
...................................................................................
			Global Vs Local Component Registration
.................................................................................

=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").
=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.

=>This can affect long-term maintainability similar to using too many global variables.

=>Global Components need to be imported inside any where

<script>
// import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <StatusBar></StatusBar>
    <Hello></Hello>
</template>
<style>
</style>
....................................................................................
....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).



This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   <greeter>
Vue supports both cases , but highly recommened is Pascal Case

eg:
<script>
//import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    //Hello is just Component
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <!-- Pascal Case -->
    <!-- <StatusBar></StatusBar> -->
    <!-- <Hello></Hello> -->
    <!-- dash-case/ kebab-case -->
    <status-bar></status-bar>
    <hello></hello>
</template>
<style>
</style>
....................................................................................
			 Vue dev Tool
....................................................................................
This is developer tool installed as part of browser plugin used for understanding component structure and its relationship.

https://devtools.vuejs.org/

.....................................................................................
			    Templates
...................................................................................
Template is the representation of View
View is Runtime representation
				
Template can be static or dynamic 

Static templates are having pure html code
Dynamic templates are having html code + Vue instructions
Vue instructions are special symbols

Template  = html + vue instructions(data,events,props...)


Data Binding:
    Passing data from the component to "View-UI"  and View to Component

Types of Data bidning:

1.interpolation
2.property /props binding
3.attribute binding
4.event binding
5.Two way data binding
6.class and style binding
.....................................................................................
.....................................................................................
			  MVC  Architecture
....................................................................................

In order to build user interface we have architectures

1.MVC 
  It is the most legacy arch but still more popular arch, used in server side,client   side app developments

2.Flex 
   It is discovered by face book, in order to replace MVC , primarily used in React..

Vue js is MVC Based  and Flex mixed arch -hybrid arch..

M - Model - State - Data
V - View  - User interface
C - Controller - Having data and biz logic

Vue and MVC:

<script>
  M + C -> logic
</script>
<template>
   View Logic - Ui
</template>
<style>

</style>

component = {Model + Controller(Script,View(template,style)}
....................................................................................
				Interpolation
...................................................................................

Transfering state(data) from controller to View.

State:
  State can be represented in two ways...

1.Primitives
   numbers,string,booleans
 let name='Subramaian'

2.Objects and Collections -  literal objects and arrays

  let profile = {
    id:1,
    name:'xxx'
  }

SFC:
 1.Using Options api
 2.Using Compostion api
    -with setup fun
    -with setup attribute

1.Using options api

let options = {
  components: {},
  data: function(){},  
}

State Declarations and Options api:
...................................

src/compoents/Greeter.vue
<script>
export default {
    //data/state declaration
    data() {
        //must return object -state
        return {
            name: 'Subramanian'
        }
    }

}
</script>
<template>
    <h1>Welcome to </h1>
</template>

src/App.vue
<script>
import Greeter from './components/Greeter.vue'
export default {
  components: { Greeter }
}
</script>
<template>
  <Greeter />
</template>

We  have declared data inside data function.

How to show or bind the data inside template?

Vue offers the syntax called binding - interpolation - {{variable}}

src/compoents/Greeter.vue
<script>
export default {
    //data/state declaration
    data() {
        //must return object -state
        return {
            name: 'Subramanian'
        }
    }

}
</script>
<template>
    <h1>Welcome to {{ name }} </h1>
</template>
.....................................................................................
			Binding all types of data
.....................................................................................


src/compoents/Profile.vue
<script>
export default {
    data() {
        return {
            id: 1,
            firstName: 'Subramanain',
            lastName: 'Murugan',
            points: 100,
            status: true,
            address: {
                city: 'Coimbatore',
                state: 'Tamil Nadu',
                country: 'India',
            }
        }
    }
}
</script>
<template>
    <h1>ID {{ id }}</h1>
    <h2>Name {{ firstName }} {{ lastName }}</h2>
    <h3>Points {{ points }}</h3>
    <h3>Status {{ status ? 'Available' : 'Not Available' }}</h3>
    <address>
        <p>{{ address.city }}, {{ address.state }}</p>
    </address>
</template>
<style></style>

src/App.vue
<script>
import Profile from './components/Profile.vue';
export default {
    components: { Profile }
}
</script>
<template>
    <Profile />
</template>
.....................................................................................
			Using Compostion api -setup function
.....................................................................................

The component logic must be encapsulated inside a function called "setup"
The setup function must return state

export default {
  setup(){
     //variables 
     //state	
     return {}
  }

}

src/compoents/Profile.vue
<script>
export default {
    setup() {
        const id = 1;
        const firstName = 'Subramanian'
        const lastName = 'Murugan';
        const status = true
        const address = {
            city: "Coimbatore",
            state: "Tamil Nadu"
        }
        return {
            id,
            firstName,
            lastName,
            status,
            address
        }
    }
}
</script>
<template>
    <h1>ID {{ id }}</h1>
    <h2>Name {{ firstName }} {{ lastName }}</h2>
    <h3>Points {{ points }}</h3>
    <h3>Status {{ status ? 'Available' : 'Not Available' }}</h3>
    <address>
        <p>{{ address.city }}, {{ address.state }}</p>
    </address>
</template>
<style></style>

src/App.vue

<script>
import Profile from './components/Profile.vue';
export default {
    components: { Profile },
    setup() {

    }
}
</script>
<template>
    <Profile />
</template> 

...................................................................................
			Compostion api using set up attribute
.....................................................................................

src/components/Profile.vue
<script setup>
const id = 1;
const firstName = 'Subramanian'
const lastName = 'Murugan';
const status = true
const address = {
    city: "Coimbatore",
    state: "Tamil Nadu"
}
</script>
<template>
    <h1>ID {{ id }}</h1>
    <h2>Name {{ firstName }} {{ lastName }}</h2>
    <h3>Points {{ points }}</h3>
    <h3>Status {{ status ? 'Available' : 'Not Available' }}</h3>
    <address>
        <p>{{ address.city }}, {{ address.state }}</p>
    </address>
</template>
<style></style>
....................................................................................
				Directives
..................................................................................

What is directive?
  Directive is object which helps to create custom elements and attributes.
  Directives enchances existing html elements - We extend the functionality of HTML   elements.

HTML elements Types:

1.Built in element and attributes
2.Custom elements and attributes

Built in Elements:
  The elements which are provided by html language.
<div>
<h1>

HTML Compiler Work flow:
.......................


<h1>Hello</h1> -----Compiler verfies this element is built in or not
				|
		   --------------------------------
		   |                              |
                 Yes                             No
		  |                              |
Browser parses, the                    Brower throws exception                                                               called "UnknownElement"
element and convert                    which is converted into plain ascii node
it , render accordingly


<app-drawer> - it is custom element, generally browser does not under stand.

In 2007, W3c introduced new idea that developers can add their own tags/elements(custom elements and custom attributes).
   HTML 5 Specification


built in element logic is already written, so that browser easily understands that.

What about custom element, how to teach browser to understand custom elements?
    
  "Through Javascript"

<app-drawer> ---|JS Code--->Runs ---renders in the browser....
   
Every Component  element is custom element.

src/components/AppDrawer.vue
<script setup>
</script>
<template>
    <h1>App Drawer</h1>
</template>

src/App.vue
<script setup>
import AppDrawer from './components/AppDrawer.vue';
</script>
<template>
    <!-- Custom element  -->
    <app-drawer></app-drawer>
</template>

Directive is also custom element, component is subclass of Directive.
.....................................................................................
			  HTML ATTRIBUTES 
.....................................................................................
Types of HTML Attributes

1.InBuilt Attributes
2.Custom Attributes

InBuilt Attributes:

<img src="" alt="">
      |      |
       Attributes - Built in Attributes

Browser knows how to put logic to src and alt.

2.Custom Attributes

 <img abc />
       |
    custom attribute

How to teach browser to parse custom attributes?
    "Through javascript"

How to create custom attributes?
  Via Directives

You can see already vue is adding custom attributes 

<div id="app" data-v-app>

</div>

Here data-v-app is custom attribute(directive)
................................................................................

Vue js helps to add custom attributes on existing elements via "directives" - Attribute Directives

Vue js attribute directive syntax:

v-directiveName

Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

Special Attributes
key
ref
is
....................................................................................
			 V-text and v-html
.....................................................................................

v-html and v-text is alternate to {{}} for data binding

<!-- Data binding with directives -->

<script setup>
const firstName = 'Subramanian'
</script>
<template>
    <h1>Interpolation using mustache notation</h1>
    <p>Name {{ firstName }}</p>
    <h1>Interpolation using Directives v-text</h1>
    <p v-text="`Name ${firstName}`"></p>
    <h1>Interpolation using Directives v-html</h1>
    <p v-html="`Name ${firstName}`"></p>
</template>

{{}} and v-text -output would be "Plain Text" -rawText
v-html -output would be "innerHTML" -rawhtml

....................................................................................
			 v-bind
...................................................................................

v-binds binds html attributes values or components values(properties) dynamically.

Binding: Attach value to the attribute

Types of binding

1.Static binding
 
   Binding attribute values once,it cant be changed during runtime.

eg:
   <img src="logo.png"/>
         |      |
  attribute   attribute value
  The value of "src" cant be changed once ui is rendered

2.Dynamic binding
 Binding attribute values initalialy, later can be changed during runtime.
 dynamic binding can be implemented using "v-bind" directive

  <img v-bind:src="variableHoldingImage"/>
  shortcut:
  <img :src="variableHoldingImage"/>


<script setup>
const logoUrl = "/src/assets/logo.svg"
const isEnabled = true
const isHidden = false
</script>
<template>
    <div>
        <h1>Bind Directives</h1>
        <div>
            <h2>Static Binding</h2>
            <img src="./assets/logo.svg" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Binding with v-bind</h2>
            <img v-bind:src="logoUrl" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Binding with v-bind shortcut</h2>
            <img :src="logoUrl" height="100" width="100" />
        </div>
        <div>
            <h2>Dynamic Binding with Button Enabled and Disabled state</h2>
            <button :disabled="isEnabled">Hello</button>
        </div>
        <div>
            <h2>Dynamic Binding with Article Show and Hidden</h2>
            <article :hidden="isHidden">
                <p>This is article</p>
            </article>
        </div>
    </div>
</template>
.....................................................................................
			  Props - Property Binding
.....................................................................................

Component Driven Design principles:

Role of Components / Responsibility of Component:
..................................................

Component having state,bizlogic,ui

As per component design design principles , we need to apply modularity concept.
  Break the component based on two aspects

1.Having data and biz logic
    -Parent Component /Container component
2.Having UI logic
    -Child Component/Presentational Component

Data(State) Sharing Patterns/ Data(State) Representation Patterns:
....................................................

1.Props Pattern
  The data is shared from the Parent Component to Child Component.
2.State Pattern
   The data is represented within in component and change it.

Syntax:
 From Parent Component Template

  <Child title="Hello" />
          |        |  
Property Name   Property Value

How to structure a Large scale vue.js app

Default strcture

src
  |
  components
    |
    User 
    Product
    Comments
    Payment
 |
 App.vue
 main.js

Standard Structure of apps would be domain model

src
  |
  components
    |
    User 
      Userlist.vue
      UserDetails.vue
      User.vue
   Product	
      ProductList.vue
      ProductDetails.vue
      Product.vue
   stores
   layouts
   plugins
   directives
   helpers/utils
...................................................................................
			  Props/Property -Pattern Implementation
...................................................................................

How to pass data from the parent component to child component?

We have many api styles (options and composition api(setup fun/setup attribute)

Props with Options Api.
.......................

Static Binding: 
  Props value once supplied cant be passed value dynamically.

src/components/products/ProductMaster.vue
<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: { ProductDetails }
}
</script>
<template>
    <h1>Product Master</h1>
    <!-- sending data from Productmaster to ProductDetails -->
    <ProductDetails title="Product Details Page"></ProductDetails>
</template>


src/components/products/ProductDetails.vue
<script>
export default {
    props: ['title']
}
</script>
<template>
    <h1>{{ title }}</h1>
</template>

src/App.vue
<script setup>
import ProductMaster from './components/products/ProductMaster.vue'

</script>
<template>
  <h1>App</h1>
  <ProductMaster></ProductMaster>
</template>
.....................................................................................

How to pass object as prop? Dynamic values?
  Using v-bind:prop or :prop 

src/components/products/ProductMaster.vue

<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: { ProductDetails },
    data() {
        return {
            product: {
                id: 1,
                name: 'IPHONE',
                model: '15 Max Pro',
                qty: 10,
                price: 124000,
                inStock: true
            }
        }
    }
}
</script>
<template>
    <h1>Product Master</h1>
    <!-- sending data from Productmaster to ProductDetails -->
    <!-- <ProductDetails title="Product Details Page" v-bind:product="product"></ProductDetails> -->
    <ProductDetails title="Product Details Page" :product="product"></ProductDetails>
</template>


src/components/products/ProductDetails.vue
<script>
export default {
    props: ['title', 'product']
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>Id {{ product.id }}</h1>
        <h2>Name {{ product.name }}</h2>
        <h2>Model {{ product.model }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? 'Available' : 'Out of Stock' }}</h2>

    </div>
</template>
...................................................................................
			 Props Composition Api - Setup function
....................................................................................

src/components/products/ProductMaster.vue
<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: { ProductDetails },
    setup() {
        return {
            product: {
                id: 1,
                name: 'IPHONE',
                model: '15 Max Pro',
                qty: 10,
                price: 124000,
                inStock: true
            }
        }
    }
}
</script>
<template>
    <h1>Product Master</h1>
    <ProductDetails title="Product Details Page" :product="product"></ProductDetails>
</template>


src/components/products/ProductDetails.vue
<script>
export default {
    props: ['title', 'product'],
    setup() {

    }
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>Id {{ product.id }}</h1>
        <h2>Name {{ product.name }}</h2>
        <h2>Model {{ product.model }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? 'Available' : 'Out of Stock' }}</h2>

    </div>
</template>
...................................................................................
			 Props Composition Api - Setup attribute
....................................................................................

src/components/products/ProductMaster.vue
<script setup>
import ProductDetails from './ProductDetails.vue'
const product = {
    id: 1,
    name: 'IPHONE',
    model: '15 Max Pro',
    qty: 10,
    price: 124000,
    inStock: true
}
</script>
<template>
    <h1>Product Master</h1>
    <ProductDetails title="Product Details Page" :product="product"></ProductDetails>
</template>

Reading props in setup attribute:
.................................
In vue 3 , we have function called "defineProps" which is global function, can be used to read props.

src/components/products/ProductDetails.vue
<script setup>
const props = defineProps(['title', 'product'])
</script>
<template>
    <h1>{{ props.title }}</h1>
    <div>
        <h1>Id {{ props.product.id }}</h1>
        <h2>Name {{ props.product.name }}</h2>
        <h2>Model {{ props.product.model }}</h2>
        <h2>Price {{ props.product.price }}</h2>
        <h2>Qty {{ props.product.qty }}</h2>
        <h2>Stock {{ props.product.inStock ? 'Available' : 'Out of Stock' }}</h2>

    </div>
</template>
..................................................................................
		What if , if you want to access props inside setup function

setup function takes "props" as arg through which you can access all properties supplied by parent component.

<script>
export default {
    props: ['title', 'product'],
    setup(props) {
        //how to access props inside setup function
        //console.log(this.props.title)
        console.log(props.title)

    }
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>Id {{ product.id }}</h1>
        <h2>Name {{ product.name }}</h2>
        <h2>Model {{ product.model }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? 'Available' : 'Out of Stock' }}</h2>

    </div>
</template>
....................................................................................
			 Property Validation
....................................................................................

Some times i want to enforce the property data type validation, which is only for runtime vertification.

eg:
 i have property called age
 i need to define rule for age that age must be number,it should not be string.

defineProps Syntax:

1.simple Syntax
defineProps(['propName','propName'])

2.Complex Syntax : prop validation rule, default value 
  
defineProps({
     age:Number,  
     id: [Number,String] // can be string or can be number
     name: {
      type:String
      required:true,
      default:'name'
     },
    status: {
	validator(value){
	  return ['OK','NotOk','Success','Failure'].includes(value)
       }
    }
 })
Runtime Types:
1.String
2.Number
3.Boolean
4.Array
5.Object
6.Date
7.Function
8.Symbol

src/components/User.vue
<script setup>
const props = defineProps({
    name: {
        type: String,
        default: 'Name is Missing'
    },
    id: {
        type: [Number, String],
        default: 0
    },
    status: {
        type: Boolean,
        default: false
    }
})
</script>
<template>
    <h1>Property validation</h1>
    <div>
        <h1>{{ props.id }}</h1>
        <h3>{{ props.name }}</h3>
        <h4>{{ props.status ? 'Available' : 'Not Available' }}</h4>
    </div>
</template>

src/App.vue
<script setup>
import User from './components/User.vue';
// const id = false
const id = 1
const name = 'Subramanian'
const status = true
</script>
<template>
    <h1>Property validation</h1>
    <User />
    <User :id="id" :name="name" :status="status" />
</template>
....................................................................................
		Can we modify the props value in Child Component
...................................................................................

As per component driven design rule, props cant be or should not be modifed by child component- Props are read only.


<script setup>
const props = defineProps({
    name: {
        type: String,
        default: 'Name is Missing'
    },
    id: {
        type: [Number, String],
        default: 0
    },
    status: {
        type: Boolean,
        default: false
    }
})
props.name = 'foo'
</script>
<template>
    <h1>Property validation</h1>
    <div>
        <h1>{{ props.id }}</h1>
        <h3>{{ props.name }}</h3>
        <h4>{{ props.status ? 'Available' : 'Not Available' }}</h4>
    </div>
</template>

Output:
Vue warn] Set operation on key "name" failed: target is readonly. Proxy(Object)
warn @ vue.js?v=2eb3f6c7:288
Show 1 more frame
Show less
vue.js?v=2eb3f6c7:288 [Vue warn] Set operation on key "name" failed: target is readonly. Proxy(Object)
....................................................................................

Assigment:

 You have to Create Customer Details

    -CustomerMaster
    -CustomerDetails

 I have to display different type of customers , you can change customer values dynamically... You can use hard-coded values

<CustomerDetails id="1"/>
<CustomerDetails id="2"/>
<CustomerDetails id="3"/>

	....................................................................................
			   Event Handling
....................................................................................
Event handling is one of the most popular concept in javascript as part of DOM programming.
Event handling helps to interact with user.
Events  are signals triggered by user or system, send to os system, the software or hardware reacts according to the event.

Events are classified into two category

1.Hardware events
   Triggered by user or system, interacts with hardware devices   
eg:
  Mouse events
    onclick,ondblclick,onmouseenter...
  https://www.w3schools.com/jsref/obj_mouseevent.asp
  Keyboard events
   onkeypress,onkeydown
  https://www.w3schools.com/jsref/event_onkeypress.asp
  Touch events
  ontouchstart,ontouchend
  https://www.w3schools.com/jsref/obj_touchevent.asp

2.Application events
   attached with objects called dom objects
   onload,oncomplete

...................................................................................
				        How event handling works

Event handling has been designed based on the design pattern called "pub-sub"/observer design pattern.

There are two actors:
1.Producer
   The producer is something who sends signals(events - name of the event and data assoicated) to the listener
2.Listener
  The Listener is someone who waits/listens for event.
  Once the event is given who reacts/respond

In js :
 Listener is function.

//event is just reference to the Event Object having information about event, and data
function listener(event){
     event.target.value
}
event object is a bridge between producer and listener

In javascript , events are given by language itself.

events are started with "on+eventName" - 
 onclick="listener"

addEventListener('click',listener)
  listeners are plain js functions with event object reference arg

Frameworks like vue,react,angular who adds their own abstractions.

We can attach event on any dom element which could be application or hardware

Vue Js and event handling:
..........................

Vue attaches events with any element with help of directive
                          "v-on"

Syntax:
1. v-on:NameOftheEvent="listener" -  v-on:click="update"
2. @click="listener" - @click="update"

Event Handling In Options API:
...............................
src/App.vue
<script>
export default {

  methods: {
    //listeners
    onIncrement(evt) {
      console.log('button is clicked')
    }
  }
}
</script>
<template>
  <h1>Event Handling</h1>
  <button v-on:click="onIncrement">Increment</button>
  <button @click="onIncrement">Increment</button>
</template>

Event Handling In Composition-Setup Function:
<script>
export default {
    setup() {
        //listener
        // function onIncrement(evt) {
        //     console.log('increment')
        // }
        //es 6 arrow functions
        const onIncrement = () => {
            console.log('increment')
        }
        //function must be returned
        return {
            onIncrement
        }
    }
}
</script>
<template>
    <h1>Event Handling</h1>
    <button @click="onIncrement">Increment</button>
</template>


Event Handling In Composition-Setup Attribute:

<script setup>
const onIncrement = () => {
    console.log('increment')
}
</script>
<template>
    <h1>Event Handling</h1>
    <button @click="onIncrement">Increment</button>
</template>
.....................................................................................
 	How to attach more than one listener on single DOM Element
.....................................................................................

<dom v-on:eventName="listener" v-on:eventName="listener">
<dom v-on="{mouseenter:listener,mouseleave:listener}">


<script setup>
const onMouseLeave = () => {
    console.log('leave')
}
const onMouseEnter = () => {
    console.log('enter')
}

</script>
<template>
    <h1>Event Handling</h1>
    <div v-on="{ mouseenter: onMouseEnter, mouseleave: onMouseLeave }">
        Touch
    </div>
</template>
.....................................................................................
		 How to pass data to the event listener
....................................................................................

syntax:
 
const getData=(data,event)=>{

}
<button @click="getData('hello',$event)">Pass data</button>

When we pass data to the listener, vue cant pass event implicitly, we have to pass event object explicitly via "$event" which is gloabl event object provided by vue.


src/App.vue
<script setup>
const onData = (data, event) => {
    console.log(data, event)
}

</script>
<template>
    <h1>Event Handling</h1>
    <button @click="onData('hello', $event)">PassData</button>
</template>
.....................................................................................
			 State -Reactive State
.....................................................................................

State means data.

How to change or update or mutate State?

"React js uses the concept called "pure functions" to change the state.
"Angular uses the concept called "Two way data" binding to change the state.
"Vue uses the concept called "Reactive State"/ "Reactivity" to change the state.


Component state contains reactie js object, when we modify them, the view updates automatically.

Through event listener, we modify the state of the object(reactive),UI gets latest value.

State update is different from options api and composition api.


Options Api:
 "data" function returns object which is by default "reactive", when ever you change that properties of the object, UI bindings gets updated automatically.

data(){
 //reactive state
  return {
     count:0
   }
}
methods: {
  onIncrement(){
    //mutate the reactive variable
    this.count++
  }

}
...................................................................................
src/App.vue
<script>
export default {
    data() {
        return {
            counter: 0
        }
    },
    methods: {
        onIncrement() {
            //mutate the state
            this.counter++
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>

How the above code works?
.....................................................................................
				Rendering Mechanism

How does vue take a template and turn into actual DOM nodes?How does vue update those DOM nodes efficiently?

Virtual DOM:

 Virtual DOM is inspired from react.js,Vue js internally uses this concept to render ui.

Virtual DOM or VDOM is programming concept when an ideal or "virtual" representation of UI is kept in memory and synced with the "real" DOM.

Render Pipeline:
................

At high level, this is what happens when a vue component is mounted...

1.Compile:
    Vue templates are compiled into render functions..that functions that return     virutal dom tree.
    This step can be done either aot via build step, or on fly by using the runtime     compiler

2.Mount:
  The runtime renderer invokes the render function, walks the returned virtual DOM   tree,and creates actual DOM nodes based on it.

3.Path:
   when a dependency used  during mount changes, the effect re-runs,This time , a new   ,updated virtual dom tree is created, the runtime renderer walks the new tree,       compares it with old one and applies necessary updates to the actual DOM


			     Compoent Reactive State
			    trigger re render process
					|
Template---compiledInto----render function code----returns--VDOM tree--mount/patch-->Actual DOM

.....................................................................................
			Component state using Compostion setup function
.....................................................................................

<script>
export default {
    setup() {
        let counter = 0
        const onIncrement = () => {
            console.log(counter)
            counter++
        }
        return {
            counter,
            onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>

After running this code,
    Here we are trying to mutate/update the "count" state variable, there is update happening but it does not trigger "view update/view renderer"

 The reason because the variables are declared within setup function is not "reactive" variables by default which is local variable, so that vue engine will not tigge re render..

We have to convert that local variable into "Reactive variable"
.....................................................................................
....................................................................................
			   Reactivity
....................................................................................

What is Reactivity?
  Reactivity is one of the core vue js concept.
Component state are "reactive javascript objects"

The word reactivity means "changing" the state(object),whenever changes happen it publishes some events, based on events,reactions happens.

Programming work flow in general

int x =10;
int y =20;

int result = x + y


when you compute this code, the runtime will execute instructions top-down pattern.
if there is change in variable (like x or y), will not update result variable
 -Sequential programming model.

What if i want to update the "result" variable value automatically when ever x or y changes.

eg:
Excel spreed sheet is one of the best eg for reactivitity programming

eg;

let A1=1
let A2=2
let A3 =A1+A2
console.log(A3) => 3

A2=4
console.log(A3) => 5

Here when you mutate A1 or A2, does not change automatically.

We can wrap this code inside function

 let A3
 function update(){
   A3 = A1 + A2
 }

in order get fresh value, we have to re-run the code that updates A3

Pointers:

1.There should be some update function, which produces a "side effect /effect".
  if any function which changes the state of the program called side effect.

2.Here ,A1 and A2 are considered dependencies of the side effect, because which helps makes side effects.
  According to dependencies, this effect is said to be "subscriber"

When ever "A1 and A2" changed, we need to invoke "update" function,which cause side effects.

It looks like event driven programming (Pub-Sub Pattern /Observerable and Observer) 

 function whenDepChange(update){
     update()
 }

 let A3
 function update(){
   A3 = A1 + A2
 }

 whenDepChange(function(){
     A3 = A1 + A2
 })
 whenDepChange(update)

Role of whenDepchange function:
................................

1.Tracking the dependencies,
    By evaulating the expression A1 and A2 ,Whether any one of them is read or not.

Vue Internal Reactivity WorkFlow:

Tracker--->triggers--whenDepChange--->runs update function---returns modified state
	
...................................................................................

...................................................................................
			  Vue js and Reactivity

Vue js uses "Reactivity subsystem" in order to track all state variables, when ever whatever changes happen, it informs the vue engine for re render process..


In Options Api pattern,

export default {
  
  data(){
   let count =0
    return {
      count:count
    }
  }

}
inside data function , if you return object, by default it is reactive, meaning that any changes detected, it starts re render ui.
In Compostion api pattern: whether is setup fun or setup attribute

<script>
export default {
 
   setup() {
    let count =0;
	return {
	  count:count
       }
   }  

}
</script>
by default setup function /setup attribute does not return reactive state..(it is normal object)

In options api every property we return is reactive, but in compostion api we can restrict reactive and non reactive.

How to declare reactive state/ how to attach reactivity feature?

Compostion Api reactive methods:
................................
ref()
computed()
reactive()
readonly()
watchEffect()
watchPostEffect()
watchSyncEffect()
watch()

ref():
 It is function which returns Object, not value

function ref<T>(value: T): Ref<UnwrapRef<T>>

interface Ref<T> {
  value: T
}
..................................................................................
			 ref implementation -setup function
...................................................................................
<script>
import { ref } from 'vue'
export default {
    setup() {
        let counter = ref(0)
        const onIncrement = () => {
            counter.value++
            console.log(counter)

        }
        return {
            counter,
            onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>
..................................................................................
			 ref implementation - setup  attribute
...................................................................................

<script setup>
import { ref } from 'vue'
let counter = ref(0)
const onIncrement = () => {
    counter.value++
    console.log(counter)
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>
.....................................................................................
			inline listeners
.....................................................................................
<script setup>
import { ref } from 'vue'
let counter = ref(0)
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="counter++">+</button>
    </div>
</template>
.....................................................................................
	Passing Values to Listener and based on that value we can mutate UI
.....................................................................................
<script setup>
import { ref } from 'vue'
let counter = ref(0)
const onIncrement = (payload, event) => {
    counter.value += payload
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement(5, $event)">+</button>
    </div>
</template>
.....................................................................................
		Multiple ref variables
....................................................................................
<script setup>
import { ref } from 'vue'
let like = ref(0)
let dislike = ref(0)
</script>
<template>
    <div>
        <h1>Like {{ like }} Dislike {{ dislike }}</h1>
        <button @click="like++">Like</button>
        <button @click="dislike++">Dislike</button>
    </div>
</template>
.....................................................................................
		 ref with literal object
.....................................................................................
<script setup>
import { ref } from 'vue'
let review = ref({ like: 0, dislike: 0 })
const onLike = () => {
    review.value.like++
}
const onDislike = () => {
    review.value.dislike++

}
</script>
<template>
    <div>
        <h1>Like {{ review.like }} Dislike {{ review.dislike }}</h1>
        <button @click="onLike">Like</button>
        <button @click="onDislike">Dislike</button>
    </div>
</template>
.....................................................................................
			 reactive api
....................................................................................
There is another way to declare reactive state, with reactive api.
Unlike ref which wraps the inner value in special object, reactive means an object itself reactive.

<script setup>
import { reactive } from 'vue'
let review = reactive({ like: 0, dislike: 0 })
const onLike = () => {
    review.like++
}
const onDislike = () => {
    review.dislike++

}
</script>
<template>
    <div>
        <h1>Like {{ review.like }} Dislike {{ review.dislike }}</h1>
        <button @click="onLike">Like</button>
        <button @click="onDislike">Dislike</button>
    </div>
</template>

ref vs reactive:
1.reactive api takes objects as parameter like literal object,collection type, such as array,map,set.It cant hold primitives such as string,number,boolean.
2.ref can take any type of data
=>reactive conversion (changes) are even updated for deep nested objects
=>reactive api compares every property in the object before ui re renders for changes.


let obj={
 
  a:1
  b: {
    c: {
     d: {
	    e:0
     }
    }
  }
}
...................................................................................
			 Nested Object and Reactive State
..................................................................................
<script setup>
import { reactive } from 'vue'
let comments = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
</script>
<template>
    <div>
        <h1>Like {{ comments.like }} Dislike {{ comments.dislike }} Rating {{ comments.recommend.rating.value }}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.recommend.rating.value++">Rating</button>

    </div>
</template>
...................................................................................	              How to avoid deep conversion with Reactive Nested object	
....................................................................................

shallowReactive:
  shallow version of reactive()
 Unlike reactive there is no deep conversion.... only root properties are reactive 
<script setup>
import { shallowReactive } from 'vue'
let comments = shallowReactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
</script>
<template>
    <div>
        <h1>Like {{ comments.like }} Dislike {{ comments.dislike }} Rating {{ comments.recommend.rating.value }}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.recommend.rating.value++">Rating</button>

    </div>
</template>
...................................................................................
		   Reactivity ,State Mutation,and Object Destructuring
...................................................................................
After reactive object destructuring , can we do state mutations?
  Reactivity will be lost once if the object is destructured..
<script setup>
import { reactive } from 'vue'
//destructure
let { like, dislike, recommend } = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
</script>
<template>
    <div>
        <h1>Like {{ like }} Dislike {{ dislike }} Rating {{ recommend.rating.value }}</h1>
        <button @click="like++">Like</button>
        <button @click="dislike++">Dislike</button>
        <button @click="recommend.rating.value++">Rating</button>

    </div>
</template>

After running this code, you see will nothing happens
    
        "Reactivity will be lost once if the object is destructured"

I need this feature, i want to destructure, and also reactivity.


How to convert destructured property into reactive?

1.toRef - Single Property
2.toRefs- Multiple Properties

<script setup>
import { reactive, toRefs } from 'vue'
//destructure
let { like, dislike, recommend } = toRefs(reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
}))
</script>
<template>
    <div>
        <h1>Like {{ like }} Dislike {{ dislike }} Rating {{ recommend.rating.value }}</h1>
        <button @click="like++">Like</button>
        <button @click="dislike++">Dislike</button>
        <button @click="recommend.rating.value++">Rating</button>

    </div>
</template>
		....................................................................................
				List Rendering -Arrays
....................................................................................
Arrays:
 =>Arrays are basic datastructure which is used to render collection of data
 =>Arrays are dynamic


Arrays and UI:
.............
  If you want to render more data, then array is used
 Arrays can help to build UI layouts in various ways.

UI layouts:
 are built with help of arrays.

1.List View
 <ul>
   <li>
 </ul>
2.Card View layout
  <div><header><section>
3.Grid view
  table
.....................................................................................
			   v-for directive
....................................................................................
  This directive used for array rendering and object rendering.

<ul>
   <li v-for="(variable,index) in array">
</ul>

 
<script setup>
import { reactive } from 'vue'
import Products from './mock-data/product'

const products = reactive(Products)
</script>
<template>
    <div>
        <h1>Vue Shop</h1>
        <div v-for="product in products">
            <h3>{{ product.id }} {{ product.title }}</h3>
            <h4>{{ product.category }}</h4>
            <p>{{ product.description }}</p>
            <h5>Price : {{ product.price }}</h5>
            <img :src="product.image" height="200" width="200">
            <h4>Rating By {{ product.rating.count }} Total Rating {{ product.rating.rate }}</h4>
        </div>
    </div>
</template>
....................................................................................			                      Key
....................................................................................
if there is re ordering in the list when we do some changes like sorting, filtering 
vue uses an alogorthim called "path"

We can tell to that alogrthim we can re arrange , that where key attribute comes into picture

Key's value must be unique.

<script setup>
import { reactive } from 'vue'
import Products from './mock-data/product'

const products = reactive(Products)
</script>
<template>
    <div>
        <h1>Vue Shop</h1>
        <div v-for="product in products" :key="product.id">
            <h3>{{ product.id }} {{ product.title }}</h3>
            <h4>{{ product.category }}</h4>
            <p>{{ product.description }}</p>
            <h5>Price : {{ product.price }}</h5>
            <img :src="product.image" height="200" width="200">
            <h4>Rating By {{ product.rating.count }} Total Rating {{ product.rating.rate }}</h4>
        </div>
    </div>
</template>
....................................................................................
			Array Mutations
.....................................................................................

How to add,delete,update array elements
........................................

<script setup>
import { reactive } from 'vue'
const todos = reactive([])

const addItem = () => {
    todos.push({ id: Math.random(), text: 'Learn vue' })
}
</script>
<template>
    <h1>Todo App</h1>
    <hr />
    <ul>
        <li v-for="todo in todos">
            <span>{{ todo }}</span>
        </li>
    </ul>
    <button @click="addItem">Add Todo</button>
</template>
....................................................................................
			   Nested List
...................................................................................

The outter arry is iterated with "Item in Array"
The inner array is iterated with "Item of NestedArray"

   <script setup>
import { reactive } from 'vue'

const persons = [
    {
        id: 1,
        name: 'A',
        friends: [
            {
                name: 'F1'
            },
            {
                name: 'F2'
            },
            {
                name: 'F3'
            }
        ]
    },
    {
        id: 2,
        name: 'B',
        friends: [
            {
                name: 'BF1'
            },
            {
                name: 'BF2'
            },
            {
                name: 'BF3'
            }
        ]
    },
    {
        id: 3,
        name: 'C',
        friends: [
            {
                name: 'CF1'
            },
            {
                name: 'CF2'
            },
            {
                name: 'CF3'
            }
        ]
    }
]

const list = reactive(persons)

</script>
<template>
    <div>
        <ul>
            <li v-for="person in list">
                <span>{{ person.name }}</span>
                <ul>
                    <li v-for="friend of person.friends">
                        <span>{{ friend.name }}</span>
                    </li>
                </ul>
            </li>
        </ul>

    </div>
</template>
....................................................................................
                          Use Case 

Render collection 
When i click the item, we need to show the details 
https://fakestoreapi.com/users
.....................................................................................
			  Watchers
....................................................................................

What is watcher?
  Watcher is a function which allows us to monitor an application state and trigger actions based on those changes.
  Watchers that allow us to observe some data and perform sepcific actions when it changes.
  It is more generic way to observe and react to data changes in the vue instance.

With watchers, we are not just able to watch a property and peform custom actions, we can alos access the old value that is particular property is changining from, as well as the new value that it has changed to.
 
Watchers in options api:
<script>
export default {
  data() {
    return {
      counter: 0
    }
  },
  watch: {
    counter(newvalue, oldvalue) {
      console.log(`new Value ${newvalue} oldValue ${oldvalue}`)
    }
  }
}
</script>
<template>
  <h1>Counter {{ counter }}</h1>
  <button @click="counter++">+</button>
</template>

<script>
import { ref, watch } from 'vue';

export default {
    setup() {
        const counter = ref(0)

        //watchers
        watch(counter, (newValue, oldValue) => {
            console.log(`New Value ${newValue} Old Value ${oldValue}`)
        })
        return {
            counter
        }
    }
}
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>

Watchers in setup attribute:
<script setup>
import { ref, watch } from 'vue';
const counter = ref(0)
//watchers
watch(counter, (newValue, oldValue) => {
    console.log(`New Value ${newValue} Old Value ${oldValue}`)
})
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>
.....................................................................................
			 Object Properties and watchers
....................................................................................
<script setup>
import { reactive, watch } from 'vue';
const comments = reactive({ like: 0, dislike: 0, recommend: { rating: { value: 0 } } })
//watchers
watch(comments, (newValue, oldValue) => {
    //console.log(`New Value ${newValue} Old Value ${oldValue}`)
    console.log(newValue)
})
</script>
<template>
    <h1>Comments {{ comments.like }}</h1>
    <button @click="comments.like++">+</button>
</template>
...................................................................................
			...................................................................................
			watch is simplified with "watchEffect" api
...............................................................................
<script setup>
import { ref, watchEffect } from 'vue';
const counter = ref(0)
//watchers
watchEffect(() => {
    console.log(counter.value)
})
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>
....................................................................................
		   Watchers in real time
....................................................................................
Real time convesion
Real time data fetch...

I give data in celsius,but i need to convert into farenheit...

<script setup>
import { ref, watch, watchEffect } from 'vue';

const tmpCelsius = ref(0)
const tempFarenheit = ref(0)
//watchers to compute farenheit
watch(tmpCelsius, (newValue) => {
    tempFarenheit.value = Math.round((newValue * 9) / 5 + 32)
})
</script>
<template>
    <h1>TtmpCelsius{{ tmpCelsius }}</h1>

    <h1>Temperature In Farenheit {{ tempFarenheit }}</h1>
    <button @click="tmpCelsius += 3">+</button>
</template>
...................................................................................
.....................................................................................
			 Computed Properties
.....................................................................................
In Vue js , there are serveral ways to set static or dynamic values to display on the template.

These inlcude using text interpolation, directly hardcoding into your HTML or even using simple expressions to modify the data.

What  are computed properties?

 In vue js, computed properties enable you to create a property that can be used to modify,manuipulate, and display data within your components in a readable and efficient manner.

You can use computed properties to calculate and display values based on a value or set of values in the data model.

It can also have some custom logic that is cached based on its dependencies, even though page reloads, it does not change..

computed properties in options api:
...................................

<script>
export default {
    data() {
        return {
            productNo: 2
        }
    },
    computed: {
        product() {
            return `Your Product No is ${this.productNo}`
        }
    }
}
</script>
<template>
    <!-- <h1>{{ 'Your Product No ' + productNo }}</h1> -->
    <h1>{{ product }}</h1>
</template>

Use cases of computed properties:
..................................
Computed properties are used to solve more complex template expression problems.

1.Filtering data
 computed properties are great for filtering data.

for eg: lets say you are filtering an array from input search bar.

<!-- Data filter with computed properties -->
<script>
import TODOS from './mock-data/todos'
export default {
    data() {
        return {
            todos: TODOS,
            searchQuery: null
        }
    },
    computed: {
        resultQuery() {
            //search logic
            if (this.searchQuery) {
                return this.todos.filter(item => {
                    return this.searchQuery.toLowerCase().split(" ").every(v => item.title.toLowerCase().includes(v))
                })

            } else {
                return this.todos
            }
        }
    }
}
</script>
<template>
    <div>
        <input v-model="searchQuery" type="text">
        <div v-for="todo in resultQuery" :key="todo.id">
            <p>{{ todo.id }} {{ todo.title }}</p>
        </div>
    </div>
</template>
...................................................................................
Dynamic Calculation:
...................
<script>
export default {
    data() {
        return {
            number: 2
        }
    },
    computed: {
        doubleIt() {
            return this.number * 2
        }
    }
}
</script>
<template>
    <div>
        {{ doubleIt }}
    </div>
</template>
.....................................................................................
Dynamic Toggling:
.................
<script>
export default {
    data() {
        return {
            status: true
        }
    },
    computed: {
        toggle() {
            if (this.status) {
                return true
            } else {
                return false
            }

        }

    }
}
</script>
<template>
    <button @click="status = !status">{{ status }}</button>
</template>
...................................................................................
			Computed Properties and Composition Api
...................................................................................

Setup and set up attribute syntax remains 


setup fun:
<script>
import { computed, ref } from 'vue';

export default {
    setup() {
        const product = ref(2)

        const productNo = computed(() => {
            return product.value
        })
        return {
            productNo
        }
    }
}
</script>
<template>
    <h1>{{ productNo }}</h1>
</template>

Search and Computed Properties:
<script setup>
import { computed, reactive } from 'vue'
import  TODOS  from './mock-data/todos'

const state = reactive({ todos: TODOS, searchQuery: null })

const resultQuery = computed(() => {
    if (state.searchQuery) {
        //filter logic 
        return state.todos.filter(item => {
            console.log(item)
            return state.searchQuery.toLowerCase().split(" ").every(v => item.title.toLowerCase().includes(v))
        });
    } else {
        return state.todos
    }
});
</script>
<template>
    <input v-model="state.searchQuery" type="text">
    <div v-for="todo in resultQuery" :key="todo.id">
        <p>{{ todo.id }} {{ todo.title }}</p>
    </div>
</template>
....................................................................................
...................................................................................
			Caching and computed Properties
		   (Normal methods vs Computed Properties)
We can write same logic using normal methods, but normal methods are not cached

<script setup>
import { computed, reactive } from 'vue'

const author = reactive({
    name: 'Subramanian',
    trainings: [
        'vue',
        'react',
        'java'
    ]
})
//computed Properties:
const TotalTrainings = computed(() => {
    console.log('computed  method')
    return author.trainings.length > 0 ? "Yes" : "No"
})

//computed properties
const TotalTrainingsNormal = () => {
    console.log('TotalTrainingsNormal  method')
    return author.trainings.length > 0 ? "Yes" : "No"
}
</script>
<template>
    {{ TotalTrainings }}
    {{ TotalTrainings }}
    {{ TotalTrainings }}
    <!--  -->
    {{ TotalTrainingsNormal() }}
    {{ TotalTrainingsNormal() }}
    {{ TotalTrainingsNormal() }}
</template>
....................................................................................
				Data Sharing Patterns
.....................................................................................
How to share data among vue components?

There are three ways of sharing data 

1.Parent to child - Props pattern
2.Child to Parent - Event Emittern Pattern.
3.Across the application - Global Pattern

....................................................................................
			Child to Parent -Event Emitter Pattern
....................................................................................

Child Component can emit event along with data, Where as Parent component listent for data.

Event emitter syntax:
 
In the child compoent

const emit =  defineEmits(['change','remove','save'])

//emit the event
emit('onNameOftheEvent',data)

In the Parent:

<Child @on-nameofftheevent="listener"/>

src/components/counter.vue
<script setup>
import { ref } from 'vue';
const counter = ref(0)
const emit = defineEmits(['onRequest'])

const onSend = () => {
    counter.value++
    //emit event
    emit('onRequest', counter.value)
}

</script>
<template>
    <h1>Child component-Counter</h1>
    <button @click="onSend">SendToParent</button>
</template>

src/App.vue
<script setup>
import { ref } from 'vue';
import Counter from './components/Counter.vue';

const childCounter = ref(0)
const getChildData = data => {
    console.log(data)
    childCounter.value = data
}
</script>
<template>
    <h1>Parent</h1>
    <h2>Data from Child {{ childCounter }}</h2>

    <hr />
    <Counter @on-request="getChildData"></Counter>
</template>
....................................................................................
			   User Interface Design - CSS -Styling
...................................................................................

CSS types

1.Global Styles
2.Component spcific styles


body {
    background-color: antiquewhite;
    margin-left: 50px;
    margin-top: 50px;
}

h1 {
    font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
}

h2 {
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
}

How to add thrid party css frameworks like bootstrap?

npm install bootstrap

main.js
import 'bootstrap/dist/css/bootstrap.min.css'

<script setup>
</script>
<template>
  <div class="container">
    <h1 style="text-align: center;color:seagreen;">Welcome to MySite</h1>
    <div class="container text-center">
      <div class="row">
        <div class="col">
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column

        </div>
        <div class="col">
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
        </div>
        <div class="col">
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
          Column
        </div>
      </div>
    </div>
  </div>
</template>
<style></style>
.....................................................................................
			Dynamic styling -Style Binding
.....................................................................................
How to bind css classes dynamically? based on some user interaction.


Static class:
<div class="box">

Dynamic class:
<div :class="{box:isActive}">

Apply box class based on "isActive" Property.

<script setup>
import { ref } from 'vue'
const isActive = ref(false)
const highLight = () => {
    if (isActive.value) {
        isActive.value = false
    } else {
        isActive.value = true
    }
}
</script>
<template>
    <h1 @mouseover="highLight" :class="{ blockquote: isActive }">Hello</h1>
</template>
.....................................................................................
Assigment:
 Show list of users , when a user is clicked you have to highlight that user and show that highlighted user details below.

Solution:
<script setup>
import { reactive, ref } from 'vue';
import Heroes from './mock-data/users'

const heroes = reactive(Heroes)
const selectedHero = ref(null)

const onSelect = (hero) => {
    selectedHero.value = hero
}
</script>
<template>
    <ul class="heroes">
        <li v-for="hero in heroes " @click="onSelect(hero)" :class="{ selected: hero === selectedHero }">
            <span class="badge">{{ hero.id }}</span> {{ hero.name }}
        </li>
    </ul>
    <div v-if="selectedHero">
        {{ selectedHero.name }}
        {{ selectedHero.email }}
    </div>
</template>
<style></style>

			Fall through Attributes
.....................................................................................
Attribute Inheritance:(HTML attributes (class) as Prop.
.......................................................

A Fall through attribute is an attribute or v-on listeners that is passed to component but it is not explcitly declared in the receiving components (Child) via props or emits.

	  Properties are inherited from the parent component to child component
	                    "class,style and id attributes"
			


src/App.vue
<!--  -->
<script setup>
import MyButton from './components/MyButton.vue';

</script>
<template>
    <!-- Here we pass class attribute as prop: attribute inheritance -->
    <MyButton class="fancy-btn"></MyButton>
</template>
<style>
.fancy-btn {
    background-color: #4CAF50;
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline;
    font-size: 16px;
}
</style>

src/components/MyButton.vue
<!--  -->
<script setup>
</script>
<template>
    <button>Click</button>
</template>
<style></style>


Now we can see the output the button automatically inherited the property..
via special variable called "attrs"...

if you want to access those attributes inside script...


Two places:

1.inside template
2.inside script block

<script>
 export default {
     created(){
	 console.log(this.$attrs)
      }
 }
</script>
using setup attribute:
<!--  -->
<script setup>
import { useAttrs } from 'vue';
const attrs = useAttrs()
console.log(attrs)
</script>
<template>
    <button>Click</button>
</template>
<style></style>

What if i have container elements?

<div>
  <button>{{ title }}</button>
</div>

Now you can see output is applied to only div element not button element.

What if i want to apply

we need to bind explicitly using "v-bind="$attrs"
<div style="background-color: ;">
        <button v-bind="$attrs">{{ title }}</button>
</div>

What if i have multiple elements to apply the same style?
 <button v-bind="$attrs">{{ title }}</button>
    <button v-bind="$attrs">{{ title }}</button>

eg:

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <div style="background-color: ;">
        <button v-bind="$attrs">{{ title }}</button>
    </div>
    <button v-bind="$attrs">{{ title }}</button>
    <button v-bind="$attrs">{{ title }}</button>
</template>
<style></style> 

....................................................................................
	 Can we override parent class attribute in child component
....................................................................................
Yes, but default which is not overriden.

How to override?
Yes, but default which is not overriden.

How to override?

Scoped style.
<!-- <script setup>
import { useAttrs } from 'vue';

const props = defineProps(['title'])
const attrs = useAttrs()
console.log(attrs)
</script>
<template>
     <button>{{ title }}</button> -->
    <!-- <span>{{ $attrs }}</span> -->
    <!-- <span>{{ attrs }}</span>
</template>
<style></style> --> 

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <div style="background-color: ;">
        <button v-bind="$attrs">{{ title }}</button>
    </div>
    <button v-bind="$attrs">{{ title }}</button>
    <button v-bind="$attrs">{{ title }}</button>
</template>
<style scoped>
.fancy-btn {
    background-color: #4c56af;   
}
</style> 
....................................................................................
		What if  i dont want attribute inheritance
...................................................................................

If your template is having more elements, attribute inheritance cant be stopped.
if your template having single element , it can be stopped.

<script setup>
const props = defineProps(['title'])
defineOptions({
    inheritAttrs: false
})
</script>
<template>
    <!-- <div style="background-color: ;">
        <button v-bind="$attrs">{{ title }}</button>
    </div>
    <button v-bind="$attrs">{{ title }}</button>
    <button v-bind="$attrs">{{ title }}</button> -->
    <button>{{ title }}</button>
</template>
<style scoped>
.fancy-btn {
    background-color: #4c56af;
}
</style> 
...................................................................................
			      Slot
			(Compoent as Prop)
....................................................................................

What can be a prop? What can be passed as prop from parent compoent to child prop?

1.Primitives -String,numbers,boolean
2.Objects 
3.Collection as prop.
4.class as prop - attribute inheritance.
5.Component as prop - Slot

How to represent Compoents?

 <MyComponent>
    ? ---> Child element -It could be DOM element or Another component
</MyCompoent>
 <MyComponent/> --->Component has no children

eg:
<Tab>
    <VideoPlayer>
<Tab>

<Tab>
    <Grid>
<Tab>

How to render videoplayer or grid?

 In order to access element or component as prop inside child (Tab) component vue offers "bulit in component -slot" - Which acts as place holder where the elements to be inserted.

src/App.component

<script setup>
import Tab from './components/Tab.vue';
import VideoPlayer from './components/VideoPlayer.vue';


</script>
<template>
  <Tab>
    <VideoPlayer />
  </Tab>
</template>
<style scoped></style>


src/components/Tab.vue
<script setup>

</script>
<template>
     <slot></slot>
</template>
<style scoped></style> 

src/components/VideoPlayer.vue
<script setup>

</script>
<template>
    <h1>Vido Player</h1>
</template>
<style scoped></style>
.....................................................................................
.....................................................................................
				Fallback Content
....................................................................................

What if i dont want to pass "element/component" as prop, if you want to display something if you dont pass-fallback.


<div>
    <ChildSlot>
	<h1>Here we are passing element</h1>
    </ChildSlot>
</div>


<div>
    <ChildSlot>
	<!--No element is passed-->
    </ChildSlot>
</div>

src/components/Tab.vue
<script setup>

</script>
<template>
    <slot>
        <!-- Fallback Content -->
        <h1>Nothing Found</h1>
    </slot>
</template>
<style scoped></style>

src/App.vue
<script setup>
import Tab from './components/Tab.vue';
import VideoPlayer from './components/VideoPlayer.vue';


</script>
<template>
  <Tab>
    <!-- <VideoPlayer /> -->
  </Tab>
</template>
<style scoped></style>
.....................................................................................
			 Multi Slots
...................................................................................


We can have more than one slot:

Without slot:
<Layout>
   <Header/>
   <Body/>
   <Footer/>
</Layout>

<Layout>
   <Header>
	<!--Header Information -->
   </Header>
   <Body>
	<!--Body Information -->
   </Body>
   <Footer>
	<!--Footer Information -->
  </Footer>
</Layout>

Eg:
 Child
  <slot name="header"></slot>

 Parent
  <template v-slot:header></template>


eg
src/App.component
<script setup>
import Layout from './components/Layout.vue'
import Header from './components/Header.vue'
import Footer from './components/Footer.vue'
import Body from './components/Body.vue'
</script>
<template>
    <Layout>
        <template v-slot:header>
            <Header />
        </template>
        <template v-slot:body>
            <Body />
        </template>
        <template v-slot:footer>
            <Footer />
        </template>
    </Layout>
</template>
<style scoped></style>

src/components/Layout.vue
<script setup>

</script>
<template>
    <slot name="header">
        <h1>Default header</h1>
    </slot>
    <slot name="body">
        <h1>Default body</h1>

    </slot>
    <slot name="footer">
        <h1>Default footer</h1>

    </slot>
</template>
<style scoped></style>

src/components/Header.vue
<script setup>

</script>
<template>
    <h1>Header</h1>
</template>
<style scoped></style>

src/components/Body.vue
<script setup>

</script>
<template>
    <p>body</p>
</template>
<style scoped></style>

src/components/Footer.vue
<script setup>

</script>
<template>
    <p>Footer</p>
</template>
<style scoped></style>
..................................................................................
				Without V-slot directive, We can use #name
..................................................................................
With vslot directive.
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- Nested Templates -->
        <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:body>
            <h1>Body</h1>
        </template>
        <template v-slot:footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>

without v-slot directive: using #name
<template>
    <h1>Vue Application</h1>
    <Layout>
        <template #header>
            <h1>Header</h1>
        </template>
        <template #body>
            <h1>Body</h1>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>

.....................................................................................				   Default Slots
....................................................................................

The slot without name is called "default slot".

In case of multi slot, we can make any one slot as default one.
.....................................................................................				   Default Slots
....................................................................................

The slot without name is called "default slot".

In case of multi slot, we can make any one slot as default one.

Child:
<script setup>
</script>
<template>
    <div>
        <header>
            <!-- <slot name="header">
                <h1>Default Header</h1>
            </slot> -->
            <!-- Default slot -->
            <slot>
                <h1>Default Header</h1>
            </slot>
        </header>
        <main>
            <slot name="body">
                <p>Default main</p>
            </slot>
        </main>
        <footer>
            <slot name="footer">
                <p>Default footer</p>
            </slot>
        </footer>
    </div>
</template>

In the parent:
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- <template #header>
            <h1>Header</h1>
        </template> -->
        <template #default>
            <h1>Header</h1>
        </template>
        <template #body>
            <h1>Body</h1>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>
....................................................................................
.....................................................................................
				Dynamic slots
.....................................................................................

The slot names can be dynamic, that means we can add slot name via reactive 

Static slot:
<template v-slot:header>
<template #header>
<template #default>

Dynamic slots:

const header = ref('header')

<template v-slot:[header]>
<template #[header]>


The slot names can be dynamic, that means we can add slot name via reactive 

Static slot:
<template v-slot:header>
<template #header>
<template #default>

Dynamic slots:

const header = ref('header')

<template v-slot:[header]>
<template #[header]>


eg:

<script setup>
import { ref } from 'vue';
import Layout from './components/slots/Layout.vue';

const header = ref('header')
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <template #[header]>
            <h1>Header</h1>
        </template>
        <template #default>
            <h1>Header</h1>
        </template>
        <template #body>
            <h1>Body</h1>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>
....................................................................................
		Global Data sharing-Dependency Injection : Composition api
....................................................................................

Prop Driling:

 When you pass data from the parent component to child, from child to its child and so on, at each level you have to pass props manually

    			Root
			 |
			 props
			 |
			Child1
			 |props
			Child2
			 |props
			Child3
			 |props
		        Child-N



<script setup>
import { ref } from 'vue';
import Child1 from './propsdrilling/Child1.vue';
const message = ref('Hello')
</script>
<template>
    <h1>Root</h1>
    <Child1 :message="message" />
</template>

Child1.vue
<script setup>
import Child2 from './Child2.vue';
const props = defineProps(['message'])
</script>
<template>
    <h1>Child 1</h1>
    <Child2 :message="props.message" />
</template>

Child2.vue
<script setup>
import Child3 from './Child3.vue';
const props = defineProps(['message'])

</script>
<template>
    <h1>Child 2</h1>
    <Child3 :message="props.message" />
</template>

Child3.vue
<script setup>
const props = defineProps(['message'])

</script>
<template>
    <h1>Child 3 {{ props.message }}</h1>
</template>

.....................................................................................
			  Form Handling
.....................................................................................

Form Controls:
1.text / password
2.Multi line text
3.checkbox
4.radio
5.select
6.submit
7.reset


How to get input from the keyboard via form controls and bind in the ui

<script setup>
import { ref } from 'vue';

const name = ref('')
const getInput = evt => {
  console.log(evt.target.value)
  name.value = evt.target.value
}
</script>
<template>
  <h1>Name {{ name }}</h1>
  <input @input="getInput">
</template>

Two way data binding:

When ever user interacts via typing in the text box, the reactive variable is updated,
when ever reactive variable is updated, the UI is rerendered.

:value property  is used to initalize the default reactive state variable in side text box

<script setup>
import { ref } from 'vue';

const name = ref('Default name')
const getInput = evt => {
  console.log(evt.target.value)
  name.value = evt.target.value
}
</script>
<template>
  <h1>Name {{ name }}</h1>
  <input @input="getInput" :value="name">
</template>
.....................................................................................
				How to reduce listeners
....................................................................................
When we have more input fields, we need to write more event listeners, which can be avoided in two ways

1.inline event listener
2.Using v-model directive


1.Inline event listener
<script setup>
import { ref } from 'vue';
const name = ref('Default name')

</script>
<template>
    <h1>Name {{ name }}</h1>
    <!-- Inline Listener -->
    <input @input="evt => name = evt.target
        .value" :value="name">
</template>

2.Using v-model directive


v-model directive can be used on other input controls as well.

textarea
  it uses value property and input event

checkbox
radio
  It uses checked property and change event
select
 It uses value property and input event .

................................................................

textbox: with model directive:
<script setup>
import { ref } from 'vue';
const name = ref('Default name')

</script>
<template>
    <h1>Name {{ name }}</h1>
    <input v-model="name">
</template>


TextArea With v-model directive:

<script setup>
import { ref } from 'vue';
const mail = ref('')

</script>
<template>
    <h1>Mail {{ mail }}</h1>
    <label id="mail">Mail</label>
    <textarea v-model="mail"  />
</template>

CheckBox:
<script setup>
import { ref } from 'vue';
const values = ref([])

</script>
<template>
    <h1>Course Information</h1>
    <input type="checkbox" id="frontend" value="FrontEnd" v-model="values" />
    <label for="frontend">Front End</label>
    <input type="checkbox" id="backend" value="Backend" v-model="values" />
    <label for="backend">Back End</label>
    <input type="checkbox" id="devops" value="Devops" v-model="values" />
    <label for="devops">Devops</label>
    <div>
        <h2>Selected Courses</h2>
        <ul>
            <li v-for="course in values">
                <span>{{ course }}</span>
            </li>
        </ul>
    </div>
</template>
.........................
Radio:
<script setup>
import { ref } from 'vue';

const choice = ref('Male')
</script>
<template>
    <div>
        <h1>Select Gender</h1>
        <input type="radio" id="Male" value="Male" checked v-model="choice" />
        <label for="Male">Male</label>
        <input type="radio" id="Female" value="Female" v-model="choice" />
        <label for="Female">Female</label>
        <input type="radio" id="ThirdGender" value="ThirdGender" v-model="choice" />
        <label for="ThirdGender">ThirdGender</label>
    </div>
    <div>
        You Have selected {{ choice }}
    </div>
</template>
..................................................................................
Select:
<script setup>
import { ref } from 'vue';

const courses = ref(["Vue", "Angular", "Microservices"])
const selectedCourses = ref('Microservices')
</script>
<template>
    <div>
        <select v-model="selectedCourses">
            <option disabled value>Select Your Course</option>
            <option v-for="course of courses">
                {{ course }}
            </option>
        </select>
    </div>
    <div>
        Your course is {{ selectedCourses }}
    </div>
</template>
<style></style>
.....................................................................................
...................................................................................
			     Advanced Form Binding Properties
...................................................................................
Value Bindings -vue custom attributes:
......................................

v-model=""
true-value="yes" //replace true or false value into meaningfull values 
false-value="no"

<script setup>
import { ref } from 'vue';
const toggle = ref(true)
const truthyValue="Yes"
</script>
<template>
    <div>
        <input type="checkbox" :true-value="truthyValue" checked false-value="no" v-model="toggle" />
        <label for="Toggle">Toggle</label>
    </div>
    <div>
        <!-- {{toggle ? "Yes" : "No"}} -->
        {{ toggle }}
    </div>
</template>

For Radio button

:true-value=""

For Select options

:value="{text: 'some text'}"
.....................................................................................
			....................................................................................
		Form Submission and How to prevent default events
....................................................................................

In java script, when you submit form, automatically there is event is fired , which is called "onSubmit" event.

onSubmit event by default looks the server url to be posted.

      <form action="http://www.google.com">
          <button>Submit</button>
      </form>

Here , the button tries to redirect to the url mentioned in the action property.

I need to control, the form submission manually.

Event Object :

has api called "preventDefault()" , which does not trigger auto form submission.

<script setup>

const onSubmit = event => {
    if (event) {
        event.preventDefault();
    }
}

</script>
<template>
    <div>
        <form action="http://www.google.com">
            <button @click="onSubmit">Submit</button>
        </form>
    </div>
</template>

Vue has some short cuts, instead of giving this inside listener, we can give inside templates.

Event Modifiers:
...............

Event Modifiers are used with v-on

<form @submit.prevent="onSubmit">

<script setup>

const onSubmit = event => {
    alert('Form to be Submitted')
}

</script>
<template>
    <div>
        <form @submit.prevent="onSubmit">
            <button>Submit</button>
        </form>
    </div>
</template>

Other event modifiers

//event propagation to be stopped
<a @click.stop="listner">

I want to submit form when key board events

<input @keyup.enter="onSubmit">

other keyboard keys modifiers

.enter
.tab
.left
.right
.space
.down
.up

.ctrl
.alt
.shift
.meta
.enter
....................................................................................
			 Form Validation
....................................................................................
Like Angular, Vue does not have any inbuilt feature to validate form.
We have to write validation logic ourselfs.
There are thrid party libs also there to validate forms.

<script setup>
import { reactive } from 'vue';

const data = reactive({
    errors: [],
    name: null,
    age: null,
    movie: null
})
const checkForm = (e) => {
    if (data.name && data.age) return true;
    data.errors = [];
    if (!data.name) data.errors.push("Name required.");
    if (!data.age) data.errors.push("Age required.");
    e.preventDefault()

}
</script>
<template>
    <form id="app" @submit="checkForm">

        <p v-if="data.errors.length">
            <b>Please correct the following error(s):</b>
        <ul>
            <li v-for="error in data.errors">{{ error }}</li>
        </ul>
        </p>

        <p>
            <label for="name">Name</label>
            <input type="text" name="name" id="name" v-model="data.name">
        </p>

        <p>
            <label for="age">Age</label>
            <input type="number" name="age" id="age" v-model="data.age" min="0">
        </p>

        <p>
            <label for="movie">Favorite Movie</label>
            <select name="movie" id="movie" v-model="data.movie">
                <option>Star Wars</option>
                <option>Vanilla Sky</option>
                <option>Atomic Blonde</option>
            </select>
        </p>

        <p>
            <input type="submit" value="Submit">
        </p>

    </form>
</template>

Third Party libs :
https://vee-validate.logaretm.com/v3/


<script setup>
import { reactive, computed } from 'vue'
import { useVuelidate } from '@vuelidate/core'
import { minLength, required, email, sameAs } from '@vuelidate/validators'

// Create a reactive "form" object to store the values of the form fields
const form = reactive({
    name: '',
    email: '',
    password: '',
    confirmPassword: ''
})
// Define validation rules for each form field using "computed"
const rules = computed(() => {
    return {
        name: { required }, // Name is required
        email: {
            required, // Email is required
            email // Must be a valid email address
        },
        password: {
            required, // Password is required
            minLength: minLength(8) // Password must have at least 8 characters
        },
        confirmPassword: {
            required, // Password confirmation is required
            sameAs: sameAs(form.password) // Must match the value of the entered password
        }
    }
})
// Use the "useVuelidate" function to perform form validation
const v$ = useVuelidate(rules, form)

// Function to handle form submission
async function handleSubmit() {
    // Validate the form fields
    const result = await v$.value.$validate()
    if (!result) {
        // If there are errors in the form, show an alert indicating that the form is invalid
        alert('The form has errors')
        return
    }
    // If the form is valid, perform some action with the form data
    console.log(form)
    alert('Form submitted successfully')
}
</script>
<template>
    <!-- The form uses @submit.prevent to capture the form submission event and execute the "handleSubmit" function. -->
    <form @submit.prevent="handleSubmit">
        <div class="field-container">
            <!-- Input field for name -->
            <label for="name">Name:</label>
            <input v-model="form.name" type="text" id="name" placeholder="Insert your name">
            <!-- Display an error message if the name field doesn't pass the validations defined in "rules" -->
            <span v-if="v$.name.$error">{{ v$.name.$errors[0].$message }}</span>
        </div>
        <div class="field-container">
            <!-- Input field for email -->
            <label for="email">Email:</label>
            <input v-model="form.email" type="text" id="email" placeholder="Insert your email">
            <!-- Display an error message if the email field doesn't pass the validations defined in "rules" -->
            <span v-if="v$.email.$error">{{ v$.email.$errors[0].$message }}</span>
        </div>
        <div class="field-container">
            <!-- Input field for password -->
            <label for="password">Password:</label>
            <input v-model="form.password" type="password" id="password" placeholder="Insert your password">
            <!-- Display an error message if the password field doesn't pass the validations defined in "rules" -->
            <span v-if="v$.password.$error">{{ v$.password.$errors[0].$message }}</span>
        </div>
        <div class="field-container">
            <!-- Input field for confirming the password -->
            <input v-model="form.confirmPassword" type="password" placeholder="Confirm password">
            <!-- Display an error message if the password confirmation field doesn't pass the validations defined in "rules" -->
            <span v-if="v$.confirmPassword.$error">{{ v$.confirmPassword.$errors[0].$message }}</span>
        </div>
        <!-- Button to submit the form -->
        <button type="submit">Sign in</button>
    </form>
</template>


<style lang="css">
form {
    width: 400px;
    margin: 0 auto;
    background-color: #f1f1f1;
    padding: 30px;
    border-radius: 20px;
}

div.field-container {
    display: flex;
    flex-direction: column;
    margin-bottom: 10px;
    height: 118px;
}

label {
    text-align: left;
}

input {
    display: block;
    box-sizing: border-box;
    border: none;
    outline: none;
    border-bottom: 1px solid #ddd;
    border-radius: 20px;
    font-size: 1em;
    padding: 20px;
    margin: 10px 0 5px 0;
    width: 100%;
}

span {
    color: red;
    font-size: 0.8em;
    text-align: left;
}

button {
    background-color: #3498db;
    padding: 10px 20px;
    margin-top: 10px;
    border: none;
    color: white;
}
</style>
.............................&&&&&&&&&&&&&&..........................................
			Component Life Cycles
....................................................................................

Component has three phase of life cycles

1.Mount
   inital render
2.Update
   when user interacts
3.unMount
  when comonent is removed from memory.

Methods:
 onMounted,onUpdated,onUnMounted

onMounted method is generally and mostly used method...

src/App.vue
<script setup>
import { onBeforeMount, onBeforeUpdate, onMounted, onUpdated, ref } from 'vue';

const counter = ref(0)
onBeforeMount(() => {
  console.log('before mount')
})
//after mount: after ui is rendered
onMounted(() => {
  console.log('after mount')
})
onBeforeUpdate(() => {
  console.log('before update')
})
//after update: after ui is updated
onUpdated(() => {
  console.log('after update')
})
</script>
<template>
  <h1>Component Life Cycles</h1>
  <h2>Counter {{ counter }}</h2>
  <button @click="counter++">+</button>
</template>
...................................................................................
			API calls in Vue
....................................................................................

Patterns:
1.you can write api call within component
2.you can write api call outside component using composable
3.you can write api call outside component using state management libs

"Vue has no any opinion to select lib for making api calls, you can use fetch,axios"


Api calls can be made during inital page render-mounted
Api calls can be made during user interaction.

1.you can write api call within component

conditional rendering:
  render ui according to some condition: using if...else

v-if
v-if ...v..else

<div v-if="Math.random() > 0.5">
  Now you see me
</div>
<div v-else>
  Now you don't
</div>

<script setup>
import { onMounted, ref } from 'vue';

const data = ref(null)
const error = ref(null)

//function to fetch data 
const fetchData = async () => {
    const url = 'https://jsonplaceholder.typicode.com/todos'
    try {
        const response = await fetch(url)
        const todos = await response.json()
        console.log(todos)
        data.value = todos
    }
    catch (err) {
        console.log(err)
        error.value = err
    }
}

//onMounted: all api calls must be made after dom ready
onMounted(() => {
    //fetchData()
    //in order to show some delay we can use timer: todo:you can remove after testing
    setTimeout(() => {
        fetchData()
    }, 5000)
})
</script>
<template>
    <h1>Todo App :(Fetch data from api)</h1>
    <!-- Conditional rendering -->
    <div v-if="error">{{ error.message }}</div>
    <div v-else-if="data">
        <ul>
            <li v-for="todo of data">
                {{ todo.title }}
            </li>
        </ul>
    </div>
    <!-- Display spinner -->
    <div v-else>
        <h1>Loading....</h1>
    </div>
</template>
.....................................................................................
				Composables-Hooks
.....................................................................................

What is a "Composable"?

 In the context of Vue applications, a "composable" is a function that leverages Vue's Composition API to encapsulate and reuse stateful logic.

When building frontend applications, we often need to reuse logic for common tasks. For example, we may need to format dates in many places, so we extract a reusable function for that. 

This formatter function encapsulates stateless logic: it takes some input and immediately returns expected output. There are many libraries out there for reusing stateless logic

Statefull logic is that manages/updates state that changes over time.

What are the concepts available for reusablity?

1.Component 
    You can reuse component where ever you want.
2.Directives
    Once the directive is created that can be where ever you want.
   v-model, v-on,v-bind
3.Composable
   Reusing statefull logic -  javascript code, kind of utility functions
.....................................................................................
			
Use case:
 Mouse Tracker
    i want to implement mouse tracking position.
 what if i want mouse tracking feature in many places in the app.

Mouse Tracking feature within Component:
........................................
src/App.vue
<!-- Mouse Tracking feature -->
<script setup>
import { onMounted, onUnmounted, ref } from 'vue';

const x = ref(0)
const y = ref(0)

const update = evt => {
    x.value = evt.pageX
    y.value = evt.pageY
}
//
onMounted(() => {
    window.addEventListener('mousemove', update)
})
onUnmounted(() => {
    window.removeEventListener('mousemove', update)
})

</script>
<template>
    <h1>Mouse Positions are at X: {{ x }} Y:{{ y }}</h1>
</template>

In the above example mouse tracking feature is locked with in this component, what if i want the same logic inside another component.

Solution:
 Composables.

=>Composable is just plain javascript function
=>Composables must be written into separte file and folders.
=>file Name convention is "useMouseTracker.js"
=>composable function may take parameter or return values.
=>function name convention is "useMouseTrack"
Mouse Tracker Example

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const x = ref(0)
const y = ref(0)

function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}

onMounted(() => window.addEventListener('mousemove', update))
onUnmounted(() => window.removeEventListener('mousemove', update))
</script>

<template>Mouse position is at: {{ x }}, {{ y }}</template>

But what if we want to reuse the same logic in multiple components? We can extract the logic into an external file, as a composable function:

// mouse.js
import { ref, onMounted, onUnmounted } from 'vue'

// by convention, composable function names start with "use"
export function useMouse() {
  // state encapsulated and managed by the composable
  const x = ref(0)
  const y = ref(0)

  // a composable can update its managed state over time.
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }

  // a composable can also hook into its owner component's
  // lifecycle to setup and teardown side effects.
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))

  // expose managed state as return value
  return { x, y }
}

// event.js
import { onMounted, onBeforeUnmount } from 'vue'

export function useEventListener(target, event, callback) {
  // if you want, you can also make this
  // support selector strings as target
  onMounted(() => target.addEventListener(event, callback))
  onBeforeUnmount(() => target.removeEventListener(event, callback))
}

// mouse.js
import { ref } from 'vue'
import { useEventListener } from './event'

export function useMouse() {
  const x = ref(0)
  const y = ref(0)

  useEventListener(window, 'mousemove', (event) => {
    x.value = event.pageX
    y.value = event.pageY
  })

  return { x, y }
}
.....................................................................................
			Composables and API Calls
.....................................................................................

src/composables/useFetch.js

import { onMounted, ref } from "vue"

export function useFetch(url) {
    const data = ref(null)
    const error = ref(null)
    async function init() {
        try {
            const response = await fetch(url)
            const items = await response.json()
            //update state 
            data.value = items
        }
        catch (err) {
            error.value = err
        }
    }
    onMounted(() => {
        init()
    })
    return {
        data, error
    }
}
src/App.vue
<script setup>
import { useFetch } from './composables/useFetch'
const { data, error } = useFetch('https://jsonplaceholder.typicode.com/todos')
</script>
<template>
    <h1>Todo App :(Fetch data from api)</h1>
    <!-- Conditional rendering -->
    <div v-if="error">{{ error.message }}</div>
    <div v-else-if="data">
        <ul>
            <li v-for="todo of data">
                {{ todo.title }}
            </li>
        </ul>
    </div>
    <!-- Display spinner -->
    <div v-else>
        <h1>Loading....</h1>
    </div>
</template>
....................................................................................
			 Accepting Reactive state Composables
.....................................................................................
useFetch('https://jsonplaceholder.typicode.com/todos')
 It takes a static URL string as input, so it performs the fetch only once, and it is then done.

What if we want to re-fetch whenever the url changes? in order to achive this, we have to pass reactive state into composable function, and let the composables create watchers that performs actions using the passed state....

const url = 'https://jsonplaceholder.typicode.com/todos' //static url
useFetch(url)

const url = ref(url) //dynamic url

url.value = '/new-url' - trigger refetch...

const {data,error} = useFetch(()=>`/todos/${id}`)

src/composables/useFetchDynamic.js
import { ref, toValue, watchEffect } from "vue";

export function useFetch(url) {

    const data = ref(null)
    const error = ref(null)

    watchEffect(() => {
        data.value = null
        error.value = null
        async function init() {
            try {
                const response = await fetch(toValue(url))
                const items = await response.json()
                //update state 
                data.value = items
            }
            catch (err) {
                error.value = err
            }
        }
        init()
    })
    return {
        data, error
    }

}
src/App.vue
<script setup>
import { ref } from 'vue';
import { useFetch } from './composables/useFetchDynamic'

const url = ref('https://jsonplaceholder.typicode.com/todos')
const { data, error } = useFetch(url)
</script>
<template>
    <h1>Todo App :(Fetch data from api)</h1>
    <!-- Conditional rendering -->
    <div v-if="
">{{ error.message }}</div>
    <div v-else-if="data">
        <ul>
            <li v-for="todo of data">
                {{ todo.title }}
            </li>
        </ul>
    </div>
    <!-- Display spinner -->
    <div v-else>
        <h1>Loading....</h1>
    </div>
</template>
.....................................................................................
			Custom Directives
....................................................................................
Directives are used to reuse dom features.

Types of directives

1.built in directives
2.Custom Directives

How to create simple custom directives?

Every Directive is plain object.

<script setup>
const vFocus = {
  //define life cycle methods
  mounted: (element) => {
    //we can get dom element here, on which element you have attached 
    console.log(element)
    element.focus()

  }
}
</script>
<template>
  <h1>Custom Directives</h1>
  <input v-focus>
</template>
....................................................................................
			  DOM Manipulation using Directives
....................................................................................
<script setup>
const vHighlight = {
    mounted: (element) => {
        element.addEventListener('mousemove', evt => {
            highlight('yellow')
        })
        element.addEventListener('mouseleave', evt => {
            highlight(null)
        })
        const highlight = color => {
            element.style.backgroundColor = color
        }
    }

}
</script>
<template>
    <h1 v-highlight>Custom Directives</h1>
</template>
.....................................................................................
		     Generally directives are created globally.

// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .directive('foucs', (element, binding) => {
        console.log(element)
        element.focus()
    })
    .mount('#app')




.....................................................................................
			  Directive Parameters,Modifiers,Args
.....................................................................................

Eg:
<input v-bind:value="msg">
		      |
		   parameter

// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .directive('foucs', (element, binding) => {
        console.log(element)
        element.focus()
    })
    .directive('highlight', (element, binding) => {
        console.log('element', element)
        console.log('binding', binding)
        element.style.backgroundColor = binding.value
        element.addEventListener('mousemove', evt => {
            highlight('yellow')
        })
        element.addEventListener('mouseleave', evt => {
            highlight(binding.value)
        })
        const highlight = color => {
            element.style.backgroundColor = color
        }
    })
    .mount('#app')
.....................................................................................
			  Plugins
.....................................................................................
What is plugin?

   Plugins are self contained code that usually add top level functionality to vue.
Most of the third party libs are integrated as plugin with vue echo system.
eg: Vue-Router,State Management libs like vuex,Pinia...

Plugins are distributed as npm moudles,in order to use plugins, we have to do two things

1.install plugin as npm module
2.Integrate with application object

const app =createApp(App)

app.directives()
app.component()
app.provide()

//plugins
app.use(myPlugin)
app.use(router)
app.use(pina)

How to write custom plugins?

src/plugins/myPlugin.js

export const myPlugin = {
    //install method 
    install(app, options) {
        //applications object referenced in the plugin as first Parameter.
        console.log(app)
        //add new api into application object so that, that will be available across the app 
        app.config.globalProperties.$uppercase = key => {
            return key.toUpperCase()
        }
    }
}

src/main.js
// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
import { myPlugin } from './plugins/myPlugin'

createApp(App)
    //register plugin
    .use(myPlugin)
    .mount('#app')

App.vue
<script setup>
</script>
<template>
    <h1>{{ $uppercase('Vue Plugins') }}</h1>
</template>
